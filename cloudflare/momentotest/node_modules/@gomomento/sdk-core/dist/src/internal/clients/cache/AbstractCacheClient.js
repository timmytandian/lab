"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.AbstractCacheClient = void 0;
const index_1 = require("../../../index");
const momento_cache_1 = require("./momento-cache");
class AbstractCacheClient {
    constructor(controlClient, dataClients, pingClient) {
        this.controlClient = controlClient;
        this.dataClients = dataClients;
        this.pingClient = pingClient;
        // We round-robin the requests through all of our clients.  Since javascript
        // is single-threaded, we don't have to worry about thread safety on this
        // index variable.
        this.nextDataClientIndex = 0;
    }
    cache(cacheName) {
        return new momento_cache_1.MomentoCache(this, cacheName);
    }
    /**
     * Ping the service to verify it is up and running
     */
    async ping() {
        var _a;
        return await ((_a = this.pingClient) === null || _a === void 0 ? void 0 : _a.ping());
    }
    /**
     * Creates a cache if it does not exist.
     *
     * @param {string} cacheName - The cache to be created.
     * @returns {Promise<CreateCache.Response>} -
     * {@link CreateCache.Success} on success.
     * {@link CreateCache.AlreadyExists} if the cache already exists.
     * {@link CreateCache.Error} on failure.
     */
    async createCache(cacheName) {
        return await this.controlClient.createCache(cacheName);
    }
    /**
     * Deletes a cache and all items stored in it.
     *
     * @param {string} cacheName - The cache to delete.
     * @returns {Promise<DeleteCache.Response>} -
     * {@link DeleteCache.Success} on success.
     * {@link DeleteCache.Error} on failure.
     */
    async deleteCache(cacheName) {
        return await this.controlClient.deleteCache(cacheName);
    }
    /**
     * Lists all caches.
     *
     * @returns {Promise<ListCaches.Response>} -
     * {@link ListCaches.Success} containing the list on success.
     * {@link ListCaches.Error} on failure.
     */
    async listCaches() {
        return await this.controlClient.listCaches();
    }
    /**
     * Gets the value stored for the given key.
     *
     * @param {string} cacheName - The cache to perform the lookup in.
     * @param {string | Uint8Array} key - The key to look up.
     * @returns {Promise<CacheGet.Response>} -
     * {@link CacheGet.Hit} containing the value if one is found.
     * {@link CacheGet.Miss} if the key does not exist.
     * {@link CacheGet.Error} on failure.
     */
    async get(cacheName, key) {
        return await this.getNextDataClient().get(cacheName, key);
    }
    /**
     * Associates the given key with the given value. If a value for the key is
     * already present it is replaced with the new value.
     *
     * @param {string} cacheName - The cache to store the value in.
     * @param {string | Uint8Array} key - The key to set.
     * @param {string | Uint8Array} value - The value to be stored.
     * @param {SetOptions} [options]
     * @param {number} [options.ttl] - The time to live for the item in the cache.
     * Uses the client's default TTL if this is not supplied.
     * @returns {Promise<CacheSet.Response>} -
     * {@link CacheSet.Success} on success.
     * {@link CacheSet.Error} on failure.
     */
    async set(cacheName, key, value, options) {
        const client = this.getNextDataClient();
        return await client.set(cacheName, key, value, options === null || options === void 0 ? void 0 : options.ttl);
    }
    /**
     * Removes the given key from the cache. The key can represent a single value
     * or a collection.
     *
     * @param {string} cacheName - The cache to delete from.
     * @param {string | Uint8Array} key - The key to delete.
     * @returns {Promise<CacheDelete.Response>} -
     * {@link CacheDelete.Success} on success.
     * {@link CacheDelete.Error} on failure.
     */
    async delete(cacheName, key) {
        const client = this.getNextDataClient();
        return await client.delete(cacheName, key);
    }
    /**
     * Adds multiple elements to the back of the given list. Creates the list if
     * it does not already exist.
     *
     * @param {string} cacheName - The cache to store the list in.
     * @param {string} listName - The list to add to.
     * @param {string[] | Uint8Array[]} values - The elements to add to the list.
     * @param {ListConcatenateBackOptions} [options]
     * @param {number} [options.truncateFrontToSize] - If the list exceeds this
     * length, remove excess from the front of the list. Must be positive.
     * @param {CollectionTtl} [options.ttl] - How the TTL should be managed.
     * Refreshes the list's TTL using the client's default if this is not
     * supplied.
     * @returns {Promise<CacheListConcatenateBack.Response>} -
     * {@link CacheListConcatenateBack.Success} on success.
     * {@link CacheListConcatenateBack.Error} on failure.
     */
    async listConcatenateBack(cacheName, listName, values, options) {
        const client = this.getNextDataClient();
        return await client.listConcatenateBack(cacheName, listName, values, options === null || options === void 0 ? void 0 : options.truncateFrontToSize, options === null || options === void 0 ? void 0 : options.ttl);
    }
    /**
     * Adds multiple elements to the front of the given list. Creates the list if
     * it does not already exist.
     *
     * @param {string} cacheName - The cache to store the list in.
     * @param {string} listName - The list to add to.
     * @param {string[] | Uint8Array[]} values - The elements to add to the list.
     * @param {ListConcatenateFrontOptions} [options]
     * @param {number} [options.truncateBackToSize] - If the list exceeds this
     * length, remove excess from the back of the list. Must be positive.
     * @param {CollectionTtl} [options.ttl] - How the TTL should be managed.
     * Refreshes the list's TTL using the client's default if this is not
     * supplied.
     * @returns {Promise<CacheListConcatenateFront.Response>} -
     * {@link CacheListConcatenateFront.Success} on success.
     * {@link CacheListConcatenateFront.Error} on failure.
     */
    async listConcatenateFront(cacheName, listName, values, options) {
        const client = this.getNextDataClient();
        return await client.listConcatenateFront(cacheName, listName, values, options === null || options === void 0 ? void 0 : options.truncateBackToSize, options === null || options === void 0 ? void 0 : options.ttl);
    }
    /**
     * Fetches all elements of the given list.
     *
     * @param {string} cacheName - The cache containing the list.
     * @param {string} listName - The list to fetch.
     * @param {ListFetchCallOptions} [options]
     * @param {number} [options.startIndex] - Start inclusive index for fetch operation.
     * @param {number} [options.endIndex] - End exclusive index for fetch operation.
     * @returns {Promise<CacheListFetch.Response>} -
     * {@link CacheListFetch.Hit} containing the list elements if the list exists.
     * {@link CacheListFetch.Miss} if the list does not exist.
     * {@link CacheListFetch.Error} on failure.
     */
    async listFetch(cacheName, listName, options) {
        const client = this.getNextDataClient();
        return await client.listFetch(cacheName, listName, options === null || options === void 0 ? void 0 : options.startIndex, options === null || options === void 0 ? void 0 : options.endIndex);
    }
    /**
     * Gets the number of elements in the given list.
     *
     * @param {string} cacheName - The cache containing the list.
     * @param {string} listName - The list to get the length of.
     * @returns {Promise<CacheListLength.Response>} -
     * {@link CacheListLength.Hit} containing the length if the list exists.
     * {@link CacheListLength.Miss} if the list does not exist.
     * {@link CacheListLength.Error} on failure.
     */
    async listLength(cacheName, listName) {
        const client = this.getNextDataClient();
        return await client.listLength(cacheName, listName);
    }
    /**
     * Gets and removes the last value from the given list.
     *
     * @param {string} cacheName - The cache containing the list.
     * @param {string} listName - The list to pop.
     * @returns {Promise<CacheListPopBack.Response>} -
     * {@link CacheListPopBack.Hit} containing the element if the list exists.
     * {@link CacheListPopBack.Miss} if the list does not exist.
     * {@link CacheListPopBack.Error} on failure.
     */
    async listPopBack(cacheName, listName) {
        const client = this.getNextDataClient();
        return await client.listPopBack(cacheName, listName);
    }
    /**
     * Gets and removes the first value from the given list.
     *
     * @param {string} cacheName - The cache containing the list.
     * @param {string} listName - The list to pop.
     * @returns {Promise<CacheListPopFront.Response>} -
     * {@link CacheListPopFront.Hit} containing the element if the list exists.
     * {@link CacheListPopFront.Miss} if the list does not exist.
     * {@link CacheListPopFront.Error} on failure.
     */
    async listPopFront(cacheName, listName) {
        const client = this.getNextDataClient();
        return await client.listPopFront(cacheName, listName);
    }
    /**
     * Adds an element to the back of the given list. Creates the list if
     * it does not already exist.
     *
     * @param {string} cacheName - The cache to store the list in.
     * @param {string} listName - The list to push to.
     * @param {string | Uint8Array} value - The value to push.
     * @param {ListPushBackOptions} [options]
     * @param {number} [options.truncateFrontToSize] - If the list exceeds this
     * length, remove excess from the front of the list. Must be positive.
     * @param {CollectionTtl} [options.ttl] - How the TTL should be managed.
     * Refreshes the list's TTL using the client's default if this is not
     * supplied.
     * @returns {Promise<CacheListPushBack.Response>} -
     * {@link CacheListPushBack.Success} containing the list's new length on
     * success.
     * {@link CacheListPushBack.Error} on failure.
     */
    async listPushBack(cacheName, listName, value, options) {
        const client = this.getNextDataClient();
        return await client.listPushBack(cacheName, listName, value, options === null || options === void 0 ? void 0 : options.truncateFrontToSize, options === null || options === void 0 ? void 0 : options.ttl);
    }
    /**
     * Adds an element to the front of the given list. Creates the list if
     * it does not already exist.
     *
     * @param {string} cacheName - The cache to store the list in.
     * @param {string} listName - The list to push to.
     * @param {string | Uint8Array} value - The value to push.
     * @param {ListPushFrontOptions} [options]
     * @param {number} [options.truncateBackToSize] - If the list exceeds this
     * length, remove excess from the end of the list. Must be positive.
     * @param {CollectionTtl} [options.ttl] - How the TTL should be managed.
     * Refreshes the list's TTL using the client's default if this is not
     * supplied.
     * @returns {Promise<CacheListPushFront.Response>} -
     * {@link CacheListPushFront.Success} containing the list's new length on
     * success.
     * {@link CacheListPushFront.Error} on failure.
     */
    async listPushFront(cacheName, listName, value, options) {
        const client = this.getNextDataClient();
        return await client.listPushFront(cacheName, listName, value, options === null || options === void 0 ? void 0 : options.truncateBackToSize, options === null || options === void 0 ? void 0 : options.ttl);
    }
    /**
     * Removes all elements from the given list equal to the given value.
     *
     * @param {string} cacheName - The cache containing the list.
     * @param {string} listName - The list to remove from.
     * @param {string | Uint8Array} value - The value to remove.
     * @returns {Promise<CacheListRemoveValue.Response>} -
     * {@link CacheListRemoveValue.Success} on success. Removing an element that
     * does not occur in the list or removing from a non-existent list counts as a
     * success.
     * {@link CacheListRemoveValue.Error} on failure.
     */
    async listRemoveValue(cacheName, listName, value) {
        const client = this.getNextDataClient();
        return await client.listRemoveValue(cacheName, listName, value);
    }
    /**
     * Retains slice of elements of a given list, deletes the rest of the list
     * that isn't being retained. Returns a Success or Error.
     *
     * @param {string} cacheName - The cache containing the list.
     * @param {string} listName - The list to retain a slice of.
     * @param {ListRetainCallOptions} [options]
     * @param {number} [options.startIndex] - Start inclusive index for fetch
     * operation. Defaults to start of array if not given, 0.
     * @param {number} [options.endIndex] - End exclusive index for fetch
     * operation. Defaults to end of array if not given.
     * @param {CollectionTtl} [options.ttl] - How the TTL should be managed.
     * Refreshes the list's TTL using the client's default if this is not
     * supplied.
     * @returns {Promise<CacheListRetain.Response>} -
     * {@link CacheListRetain.Success} on success.
     * {@link CacheListRetain.Error} on failure.
     */
    async listRetain(cacheName, listName, options) {
        const client = this.getNextDataClient();
        return await client.listRetain(cacheName, listName, options === null || options === void 0 ? void 0 : options.startIndex, options === null || options === void 0 ? void 0 : options.endIndex, options === null || options === void 0 ? void 0 : options.ttl);
    }
    /**
     * Fetches all elements of the given set
     *
     * @param {string} cacheName - The cache containing the set.
     * @param {string} setName - The set to fetch.
     * @returns {Promise<CacheSetFetch.Response>} -
     * {@link CacheSetFetch.Hit} containing the set elements if the set exists.
     * {@link CacheSetFetch.Miss} if the set does not exist.
     * {@link CacheSetFetch.Error} on failure.
     */
    async setFetch(cacheName, setName) {
        const client = this.getNextDataClient();
        return await client.setFetch(cacheName, setName);
    }
    /**
     * Adds an element to the given set. Creates the set if it does not already
     * exist.
     *
     * @remarks
     * After this operation the set will contain the union of the element passed
     * in and the original elements of the set.
     *
     * @param {string} cacheName - The cache to store the set in.
     * @param {string} setName - The set to add to.
     * @param {string | Uint8Array} element - The element to add.
     * @param {SetAddElementOptions} options
     * @param {CollectionTtl} [options.ttl] - How the TTL should be managed.
     * Refreshes the set's TTL using the client's default if this is not supplied.
     * @returns {Promise<CacheSetAddElement.Response>} -
     * {@link CacheSetAddElement.Success} on success.
     * {@link CacheSetAddElement.Error} on failure.
     */
    async setAddElement(cacheName, setName, element, options) {
        return (await this.setAddElements(cacheName, setName, [element], options)).toSingularResponse();
    }
    /**
     * Adds multiple elements to the given set. Creates the set if it does not
     * already exist.
     *
     * @remarks
     * After this operation, the set will contain the union of the elements passed
     * in and the original elements of the set.
     *
     * @param {string} cacheName - The cache to store the set in.
     * @param {string} setName - The set to add to.
     * @param {string[] | Uint8Array[]} elements - The elements to add.
     * @param {SetAddElementsOptions} options
     * @param {CollectionTtl} [options.ttl] - How the TTL should be managed.
     * Refreshes the set's TTL using the client's default if this is not supplied.
     * @returns {Promise<CacheSetAddElements.Response>} -
     * {@link CacheSetAddElements.Success} on success.
     * {@link CacheSetAddElements.Error} on failure.
     */
    async setAddElements(cacheName, setName, elements, options) {
        const client = this.getNextDataClient();
        return await client.setAddElements(cacheName, setName, elements, options === null || options === void 0 ? void 0 : options.ttl);
    }
    /**
     * Removes an element from the given set.
     *
     * @param {string} cacheName - The cache containing the set.
     * @param {string} setName - The set to remove from.
     * @param {string | Uint8Array} element - The element to remove.
     * @returns {Promise<CacheSetRemoveElement.Response>} -
     * {@link CacheSetRemoveElement.Success} on success. Removing an element that
     * does not occur in the set or removing from a non-existent set counts as a
     * success.
     * {@link CacheSetRemoveElement.Error} on failure.
     */
    async setRemoveElement(cacheName, setName, element) {
        return (await this.setRemoveElements(cacheName, setName, [element])).toSingularResponse();
    }
    /**
     * Removes multiple elements from the given set.
     *
     * @param {string} cacheName - The cache containing the set.
     * @param {string} setName - The set to remove from.
     * @param {string[] | Uint8Array[]} elements - The elements to remove.
     * @returns {Promise<CacheSetRemoveElements.Response>} -
     * {@link CacheSetRemoveElements.Success} on success. Removing elements that
     * do not occur in the set or removing from a non-existent set counts as a
     * success.
     * {@link CacheSetRemoveElements.Error} on failure.
     */
    async setRemoveElements(cacheName, setName, elements) {
        const client = this.getNextDataClient();
        return await client.setRemoveElements(cacheName, setName, elements);
    }
    /**
     * Associates the given key with the given value. If a value for the key is
     * already present it is not replaced with the new value.
     *
     * @param {string} cacheName - The cache to store the value in.
     * @param {string | Uint8Array} key - The key to set.
     * @param {string | Uint8Array} field - The value to be stored.
     * @param {SetIfNotExistsOptions} [options]
     * @param {number} [options.ttl] - The time to live for the item in the cache.
     * Uses the client's default TTL if this is not supplied.
     * @returns {Promise<CacheSetIfNotExists.Response>} -
     * {@link CacheSetIfNotExists.Stored} on storing the new value.
     * {@link CacheSetIfNotExists.NotStored} on not storing the new value.
     * {@link CacheSetIfNotExists.Error} on failure.
     */
    async setIfNotExists(cacheName, key, field, options) {
        const client = this.getNextDataClient();
        return await client.setIfNotExists(cacheName, key, field, options === null || options === void 0 ? void 0 : options.ttl);
    }
    /**
     * Flushes / clears all the items of the given cache
     *
     * @param {string} cacheName - The cache to be flushed.
     * @returns {Promise<CacheFlush.Response>} -
     * {@link CacheFlush.Success} on success.
     * {@link CacheFlush.Error} on failure.
     */
    async flushCache(cacheName) {
        return await this.controlClient.flushCache(cacheName);
    }
    /**
     * Fetches all elements of the given dictionary.
     *
     * @param {string} cacheName - The cache to perform the lookup in.
     * @param {string} dictionaryName - The dictionary to fetch.
     * @returns {Promise<CacheDictionaryFetch.Response>} -
     * {@link CacheDictionaryFetch.Hit} containing the dictionary elements if the
     * dictionary exists.
     * {@link CacheDictionaryFetch.Miss} if the dictionary does not exist.
     * {@link CacheDictionaryFetch.Error} on failure.
     */
    async dictionaryFetch(cacheName, dictionaryName) {
        const client = this.getNextDataClient();
        return await client.dictionaryFetch(cacheName, dictionaryName);
    }
    /**
     * Adds an integer quantity to a field value.
     *
     * @remarks
     * Incrementing the value of a missing field sets the value to amount.
     *
     * @param {string} cacheName - The cache containing the field.
     * @param {string | Uint8Array} field - The field to increment.
     * @param {number} amount - The quantity to add to the value. May be positive,
     * negative, or zero. Defaults to 1.
     * @param {IncrementOptions} options
     * @param {CollectionTtl} [options.ttl] - How the TTL should be managed.
     * @returns {Promise<CacheIncrement>} -
     * {@link CacheIncrement.Success} containing the incremented value
     * on success.
     * {@link CacheIncrement.Error} on failure. Incrementing a value
     * that was not set using this method or is not the string representation of
     * an integer results in a failure with a FailedPreconditionException error.
     */
    async increment(cacheName, field, amount = 1, options) {
        const client = this.getNextDataClient();
        return await client.increment(cacheName, field, amount, options === null || options === void 0 ? void 0 : options.ttl);
    }
    /**
     * Adds an element to the given dictionary. Creates the dictionary if it does
     * not already exist.
     *
     * @param {string} cacheName - The cache to store the dictionary in.
     * @param {string} dictionaryName - The dictionary to add to.
     * @param {string | Uint8Array} field - The field to set.
     * @param {string | Uint8Array} value - The value to store.
     * @param {DictionarySetFieldOptions} options
     * @param {CollectionTtl} [options.ttl] - How the TTL should be managed.
     * Refreshes the dictionary's TTL using the client's default if this is not
     * supplied.
     * @returns {Promise<CacheDictionarySetField.Response>} -
     * {@link CacheDictionarySetField.Success} on success.
     * {@link CacheDictionarySetField.Error} on failure.
     */
    async dictionarySetField(cacheName, dictionaryName, field, value, options) {
        const client = this.getNextDataClient();
        return await client.dictionarySetField(cacheName, dictionaryName, field, value, options === null || options === void 0 ? void 0 : options.ttl);
    }
    /**
     * Adds multiple elements to the given dictionary. Creates the dictionary if
     * it does not already exist.
     *
     * @param {string} cacheName - The cache to store the dictionary in.
     * @param {string} dictionaryName - The dictionary to add to.
     * @param {Map<string | Uint8Array, string | Uint8Array>} elements - The
     * elements to set.
     * @param {DictionarySetFieldsOptions} options
     * @param {CollectionTtl} [options.ttl] - How the TTL should be managed.
     * Refreshes the dictionary's TTL using the client's default if this is not
     * supplied.
     * @returns {Promise<CacheDictionarySetFields.Response>} -
     * {@link CacheDictionarySetFields.Success} on success.
     * {@link CacheDictionarySetFields.Error} on failure.
     */
    async dictionarySetFields(cacheName, dictionaryName, elements, options) {
        const client = this.getNextDataClient();
        return await client.dictionarySetFields(cacheName, dictionaryName, elements, options === null || options === void 0 ? void 0 : options.ttl);
    }
    /**
     * Gets the value stored for the given dictionary and field.
     *
     * @param {string} cacheName - The cache containing the dictionary.
     * @param {string} dictionaryName - The dictionary to look up.
     * @param {string | Uint8Array} field - The field to look up.
     * @returns {Promise<CacheDictionaryGetField.Response>} -
     * {@link CacheDictionaryGetField.Hit} containing the dictionary element if
     * one is found.
     * {@link CacheDictionaryGetField.Miss} if the dictionary does not exist.
     * {@link CacheDictionaryGetField.Error} on failure.
     */
    async dictionaryGetField(cacheName, dictionaryName, field) {
        const client = this.getNextDataClient();
        return await client.dictionaryGetField(cacheName, dictionaryName, field);
    }
    /**
     * Gets multiple values from the given dictionary.
     *
     * @param {string} cacheName - The cache containing the dictionary.
     * @param {string} dictionaryName - The dictionary to look up.
     * @param {string[] | Uint8Array[]} fields - The fields to look up.
     * @returns {Promise<CacheDictionaryGetFields.Response>} -
     * {@link CacheDictionaryGetFields.Hit} containing the dictionary elements if
     * the dictionary exists.
     * {@link CacheDictionaryGetFields.Miss} if the dictionary does not exist.
     * {@link CacheDictionaryGetFields.Error} on failure.
     */
    async dictionaryGetFields(cacheName, dictionaryName, fields) {
        const client = this.getNextDataClient();
        return await client.dictionaryGetFields(cacheName, dictionaryName, fields);
    }
    /**
     * Removes an element from the given dictionary.
     *
     * @remarks
     * Performs a no-op if the dictionary or field does not exist.
     *
     * @param {string} cacheName - The cache containing the dictionary.
     * @param {string} dictionaryName - The dictionary to remove from.
     * @param {string | Uint8Array} field - The field to remove.
     * @returns {Promise<CacheDictionaryRemoveField.Response>} -
     * {@link CacheDictionaryRemoveField.Success} on success.
     * {@link CacheDictionaryRemoveField.Error} on failure.
     */
    async dictionaryRemoveField(cacheName, dictionaryName, field) {
        const client = this.getNextDataClient();
        return await client.dictionaryRemoveField(cacheName, dictionaryName, field);
    }
    /**
     * Removes multiple fields from the given dictionary.
     *
     * @remarks
     * Performs a no-op if the dictionary or fields do not exist.
     *
     * @param {string} cacheName - The cache containing the dictionary.
     * @param {string} dictionaryName - The dictionary to remove from.
     * @param {string[] | Uint8Array[]} fields - The fields to remove.
     * @returns {Promise<CacheDictionaryRemoveFields.Response>} -
     * {@link CacheDictionaryRemoveFields.Success} on success.
     * {@link CacheDictionaryRemoveFields.Error} on failure.
     */
    async dictionaryRemoveFields(cacheName, dictionaryName, fields) {
        const client = this.getNextDataClient();
        return await client.dictionaryRemoveFields(cacheName, dictionaryName, fields);
    }
    /**
     * Adds an integer quantity to a dictionary value.
     *
     * @remarks
     * Incrementing the value of a missing field sets the value to amount.
     *
     * @param {string} cacheName - The cache containing the dictionary.
     * @param {string} dictionaryName - The dictionary to set.
     * @param {string | Uint8Array} field - The field to increment.
     * @param {number} amount - The quantity to add to the value. May be positive,
     * negative, or zero. Defaults to 1.
     * @param {DictionaryIncrementOptions} options
     * @param {CollectionTtl} [options.ttl] - How the TTL should be managed.
     * Refreshes the dictionary's TTL using the client's default if this is not
     * supplied.
     * @returns {Promise<CacheDictionaryIncrement.Response>} -
     * {@link CacheDictionaryIncrement.Success} containing the incremented value
     * on success.
     * {@link CacheDictionaryIncrement.Error} on failure. Incrementing a value
     * that was not set using this method or is not the string representation of
     * an integer results in a failure with a FailedPreconditionException error.
     */
    async dictionaryIncrement(cacheName, dictionaryName, field, amount = 1, options) {
        const client = this.getNextDataClient();
        return await client.dictionaryIncrement(cacheName, dictionaryName, field, amount, options === null || options === void 0 ? void 0 : options.ttl);
    }
    /**
     * Gets the number of elements in the given dictionary.
     *
     * @param {string} cacheName - The cache containing the dictionary.
     * @param {string} dictionaryName - The dictionary to get the length of.
     * @returns {Promise<CacheDictionaryLength.Response>} -
     * {@link CacheDictionaryLength.Hit} containing the length if the dictionary exists.
     * {@link CacheDictionaryLength.Miss} if the dictionary does not exist.
     * {@link CacheDictionaryLength.Error} on failure.
     */
    async dictionaryLength(cacheName, dictionaryName) {
        const client = this.getNextDataClient();
        return await client.dictionaryLength(cacheName, dictionaryName);
    }
    /**
     * Adds an element to the given sorted set. If the element already exists, its
     * score is updated. Creates the sorted set if it does not exist.
     *
     * @param {string} cacheName - The cache containing the sorted set.
     * @param {string} sortedSetName - The sorted set to add to.
     * @param {string | Uint8Array} value - The value to add.
     * @param {number} score - The score to assign to the value.
     * @param {SortedSetPutElementOptions} options
     * @param {CollectionTtl} [options.ttl] - How the TTL should be managed.
     * Refreshes the sorted set's TTL using the client's default if this is not
     * supplied.
     * @returns {Promise<CacheSortedSetPutElement.Response>} -
     * {@link CacheSortedSetPutElement.Success} on success.
     * {@link CacheSortedSetPutElement.Error} on failure.
     * @returns
     */
    async sortedSetPutElement(cacheName, sortedSetName, value, score, options) {
        const client = this.getNextDataClient();
        return await client.sortedSetPutElement(cacheName, sortedSetName, value, score, options === null || options === void 0 ? void 0 : options.ttl);
    }
    /**
     * Adds elements to the given sorted set. For any values that already exist, it
     * the score is updated. Creates the sorted set if it does not exist.
     *
     * @param {string} cacheName - The cache containing the sorted set.
     * @param {string} sortedSetName - The sorted set to add to.
     * @param {Map<string | Uint8Array, number>| Record<string, number>} elements - The value->score pairs to add to the sorted set.
     * @param {SortedSetPutElementOptions} options
     * @param {CollectionTtl} [options.ttl] - How the TTL should be managed.
     * Refreshes the sorted set's TTL using the client's default if this is not
     * supplied.
     * @returns {Promise<CacheSortedSetPutElements.Response>} -
     * {@link CacheSortedSetPutElements.Success} on success.
     * {@link CacheSortedSetPutElements.Error} on failure.
     * @returns
     */
    async sortedSetPutElements(cacheName, sortedSetName, elements, options) {
        const client = this.getNextDataClient();
        return await client.sortedSetPutElements(cacheName, sortedSetName, elements, options === null || options === void 0 ? void 0 : options.ttl);
    }
    /**
     * Fetch the elements in the given sorted set by index (rank).
     *
     * @param {string} cacheName - The cache containing the sorted set.
     * @param {string} sortedSetName - The sorted set to fetch from.
     * @param {SortedSetFetchByRankOptions} options
     * @param {number} [options.startRank] - The rank of the first element to
     * fetch. Defaults to 0. This rank is inclusive, ie the element at this rank
     * will be fetched.
     * @param {number} [options.endRank] - The rank of the last element to fetch.
     * This rank is exclusive, ie the element at this rank will not be fetched.
     * Defaults to null, which fetches up until and including the last element.
     * @param {SortedSetOrder} [options.order] - The order to fetch the elements in.
     * Defaults to ascending.
     * @returns {Promise<CacheSortedSetFetch.Response>}
     * {@link CacheSortedSetFetch.Hit} containing the requested elements when found.
     * {@link CacheSortedSetFetch.Miss} when the sorted set does not exist.
     * {@link CacheSortedSetFetch.Error} on failure.
     */
    async sortedSetFetchByRank(cacheName, sortedSetName, options) {
        var _a, _b;
        const client = this.getNextDataClient();
        return await client.sortedSetFetchByRank(cacheName, sortedSetName, (_a = options === null || options === void 0 ? void 0 : options.order) !== null && _a !== void 0 ? _a : index_1.SortedSetOrder.Ascending, (_b = options === null || options === void 0 ? void 0 : options.startRank) !== null && _b !== void 0 ? _b : 0, options === null || options === void 0 ? void 0 : options.endRank);
    }
    /**
     * Fetch the elements in the given sorted set by score.
     *
     * @param {string} cacheName - The cache containing the sorted set.
     * @param {string} sortedSetName - The sorted set to fetch from.
     * @param {SortedSetFetchByScoreOptions} options
     * @param {number} [options.minScore] - The minimum score (inclusive) of the
     * elements to fetch. Defaults to negative infinity.
     * @param {number} [options.maxScore] - The maximum score (inclusive) of the
     * elements to fetch. Defaults to positive infinity.
     * @param {SortedSetOrder} [options.order] - The order to fetch the elements in.
     * Defaults to ascending.
     * @param {number} [options.offset] - The number of elements to skip before
     * returning the first element. Defaults to 0. Note: this is not the rank of
     * the first element to return, but the number of elements of the result set
     * to skip before returning the first element.
     * @param {number} [options.count] - The maximum number of elements to return.
     * Defaults to undefined, which returns all elements.
     * @returns {Promise<CacheSortedSetFetch.Response>} -
     * {@link CacheSortedSetFetch.Hit} containing the requested elements when found.
     * {@link CacheSortedSetFetch.Miss} when the sorted set does not exist.
     * {@link CacheSortedSetFetch.Error} on failure.
     */
    async sortedSetFetchByScore(cacheName, sortedSetName, options) {
        var _a;
        const client = this.getNextDataClient();
        return await client.sortedSetFetchByScore(cacheName, sortedSetName, (_a = options === null || options === void 0 ? void 0 : options.order) !== null && _a !== void 0 ? _a : index_1.SortedSetOrder.Ascending, options === null || options === void 0 ? void 0 : options.minScore, options === null || options === void 0 ? void 0 : options.maxScore, options === null || options === void 0 ? void 0 : options.offset, options === null || options === void 0 ? void 0 : options.count);
    }
    /**
     * Look up the rank of an element in the sorted set, by the value of the element.
     *
     * @param {string} cacheName - The cache containing the sorted set.
     * @param {string} sortedSetName - The sorted set to fetch from.
     * @param {string | Uint8Array} value - The value of the element whose rank we are retrieving.
     * @returns {Promise<CacheSortedSetGetRank.Response>}
     * {@link CacheSortedSetGetRank.Hit} containing the rank of the requested elements when found.
     * {@link CacheSortedSetGetRank.Miss} when the element does not exist.
     * {@link CacheSortedSetGetRank.Error} on failure.
     */
    async sortedSetGetRank(cacheName, sortedSetName, value) {
        const client = this.getNextDataClient();
        return await client.sortedSetGetRank(cacheName, sortedSetName, value);
    }
    /**
     * Look up the score of an element in the sorted set, by the value of the element.
     *
     * @param {string} cacheName - The cache containing the sorted set.
     * @param {string} sortedSetName - The sorted set to fetch from.
     * @param {string | Uint8Array} value - The value of the element whose score we are retrieving.
     * @returns {Promise<CacheSortedSetGetScore.Response>}
     * {@link CacheSortedSetGetScore.Hit} containing the score of the requested element when found.
     * {@link CacheSortedSetGetScore.Miss} when the element or collection does not exist.
     * {@link CacheSortedSetGetScore.Error} on failure.
     */
    async sortedSetGetScore(cacheName, sortedSetName, value) {
        const client = this.getNextDataClient();
        return await client.sortedSetGetScore(cacheName, sortedSetName, value);
    }
    /**
     * Look up the scores of multiple elements in the sorted set, by the value of the elements.
     *
     * @param {string} cacheName - The cache containing the sorted set.
     * @param {string} sortedSetName - The sorted set to fetch from.
     * @param {string[] | Uint8Array[]} values - The values of the elements whose scores we are retrieving.
     * @returns {Promise<CacheSortedSetGetScores.Response>}
     * {@link CacheSortedSetGetScores.Hit} containing the scores of the requested elements when found.
     * {@link CacheSortedSetGetScores.Miss} when the element or collection does not exist.
     * {@link CacheSortedSetGetScores.Error} on failure.
     */
    async sortedSetGetScores(cacheName, sortedSetName, values) {
        const client = this.getNextDataClient();
        return await client.sortedSetGetScores(cacheName, sortedSetName, values);
    }
    /**
     * Increment the score of an element in the sorted set.
     *
     * @param {string} cacheName - The cache containing the sorted set.
     * @param {string} sortedSetName - The sorted set to fetch from.
     * @param {string | Uint8Array} value - The value of the element whose score we are incrementing.
     * @param {number} amount - The quantity to add to the score. May be positive,
     * negative, or zero. Defaults to 1.
     * @param {SortedSetIncrementOptions} options
     * @param {CollectionTtl} [options.ttl] - How the TTL should be managed.
     * Refreshes the sorted set's TTL using the client's default if this is not
     * supplied.
     * @returns {Promise<CacheSortedSetIncrementScore.Response>} -
     * {@link CacheSortedSetIncrementScore.Success} containing the incremented score
     * on success.
     * {@link CacheSortedSetIncrementScore.Error} on failure. Incrementing a score
     * that was not set using this method or is not the string representation of
     * an integer results in a failure with a FailedPreconditionException error.
     */
    async sortedSetIncrementScore(cacheName, sortedSetName, value, amount, options) {
        const client = this.getNextDataClient();
        return await client.sortedSetIncrementScore(cacheName, sortedSetName, value, amount || 1, options === null || options === void 0 ? void 0 : options.ttl);
    }
    /**
     * Remove an element from the sorted set
     * @param {string} cacheName - The cache containing the sorted set.
     * @param {string} sortedSetName - The sorted set to remove from.
     * @param {string | Uint8Array} value - The value of the element to remove from the set.
     * @returns {Promise<CacheSortedSetRemoveElement.Response>}
     * {@link CacheSortedSetRemoveElement.Success} if the element was successfully removed
     * {@link CacheSortedSetIncrementScore.Error} on failure
     */
    async sortedSetRemoveElement(cacheName, sortedSetName, value) {
        const client = this.getNextDataClient();
        return await client.sortedSetRemoveElement(cacheName, sortedSetName, value);
    }
    /**
     * Remove multiple elements from the sorted set
     * @param {string} cacheName - The cache containing the sorted set.
     * @param {string} sortedSetName - The sorted set to remove from.
     * @param {string | Uint8Array} values - The values of the elements to remove from the set.
     * @returns {Promise<CacheSortedSetRemoveElement.Response>}
     * {@link CacheSortedSetRemoveElement.Success} if the elements were successfully removed
     * {@link CacheSortedSetIncrementScore.Error} on failure
     */
    async sortedSetRemoveElements(cacheName, sortedSetName, values) {
        const client = this.getNextDataClient();
        return await client.sortedSetRemoveElements(cacheName, sortedSetName, values);
    }
    /**
     * Fetch length (number of items) of sorted set
     * @param {string} cacheName - The cache containing the sorted set.
     * @param {string} sortedSetName - The sorted set name.
     * @returns {Promise<CacheSortedSetLength.Response>}
     * {@link CacheSortedSetLength.Hit} containing the length if the sorted set exists.
     * {@link CacheSortedSetLength.Miss} if the sorted set does not exist.
     * {@link CacheSortedSetLength.Error} on failure.
     */
    async sortedSetLength(cacheName, sortedSetName) {
        const client = this.getNextDataClient();
        return await client.sortedSetLength(cacheName, sortedSetName);
    }
    /**
     * Fetch length (number of items) of sorted set within the provided score range
     * @param {string} cacheName - The cache containing the sorted set.
     * @param {string} sortedSetName - The sorted set name.
     * @param {SortedSetLengthByScoreOptions} options - Optional parameter for specifying the score range to search in.
     * @param {number} [options.minScore] - The lower bound on the score range to search in.
     * @param {number} [options.maxScore] - The upper bound on the score range to search in.
     * @returns {Promise<CacheSortedSetLengthByScore.Response>}
     * {@link CacheSortedSetLengthByScore.Hit} containing the length if the sorted set exists.
     * {@link CacheSortedSetLengthByScore.Miss} if the sorted set does not exist.
     * {@link CacheSortedSetLengthByScore.Error} on failure.
     */
    async sortedSetLengthByScore(cacheName, sortedSetName, options) {
        const client = this.getNextDataClient();
        return await client.sortedSetLengthByScore(cacheName, sortedSetName, options === null || options === void 0 ? void 0 : options.minScore, options === null || options === void 0 ? void 0 : options.maxScore);
    }
    /**
     * Return the type of the key in the cache
     * @param {string} cacheName - The cache containing the key.
     * @param {string} key - The key for which type is requested.
     * @returns {Promise<CacheItemGetType.Response>}
     * {@link CacheItemGetType.Hit} containing type of key when found.
     * {@link CacheItemGetType.Miss} when the key does not exist.
     * {@link CacheItemGetType.Error} on failure.
     */
    async itemGetType(cacheName, key) {
        const client = this.getNextDataClient();
        return await client.itemGetType(cacheName, key);
    }
    /**
     * Return the remaining ttl of the key in the cache in milliseconds.
     * @param {string} cacheName - The cache containing the key.
     * @param {string} key - The key for which the ttl remaining is requested.
     * @returns {Promise<CacheItemGetTtl.Response>}
     * {@link CacheItemGetTtl.Hit} containing ttl remaining of key when found.
     * {@link CacheItemGetTtl.Miss} when the key does not exist.
     * {@link CacheItemGetTtl.Error} on failure.
     */
    async itemGetTtl(cacheName, key) {
        const client = this.getNextDataClient();
        return await client.itemGetTtl(cacheName, key);
    }
    /**
     * Check if the provided key exists in the cache
     * @param {string} cacheName - The cache to look in.
     * @param {string | Uint8Array} key - The key to look up.
     * @returns {Promise<CacheKeyExists.Response>}
     * {@link CacheKeyExists.Success} if key is found? or if key is checked?
     * {@link CacheKeyExists.Error} on failure.
     */
    async keyExists(cacheName, key) {
        const client = this.getNextDataClient();
        return await client.keyExists(cacheName, key);
    }
    /**
     * Check if the provided keys exist in the cache
     * @param {string} cacheName - The cache to look in.
     * @param {string[] | Uint8Array[]} keys - The keys to look up.
     * @returns {Promise<CacheKeysExist.Response>}
     * {@link CacheKeysExist.Success} if at least one key is found? if all keys checked?
     * {@link CacheKeysExist.Error} on failure.
     */
    async keysExist(cacheName, keys) {
        const client = this.getNextDataClient();
        return await client.keysExist(cacheName, keys);
    }
    /**
     * Update the ttl of the key in the cache in milliseconds.
     * @param {string} cacheName - The cache containing the key.
     * @param {string} key - The key for which the ttl remaining is requested.
     * @param {number} ttlMilliseconds - The ttl in milliseconds that should overwrite the current ttl.
     * @returns {Promise<CacheUpdateTtl.Response>}
     * {@link CacheUpdateTtl.Set} when the ttl was successfully overwritten.
     * {@link CacheUpdateTtl.Miss} when the key does not exist.
     * {@link CacheUpdateTtl.Error} on failure.
     */
    async updateTtl(cacheName, key, ttlMilliseconds) {
        const client = this.getNextDataClient();
        return await client.updateTtl(cacheName, key, ttlMilliseconds);
    }
    /**
     * Increase the ttl of the key in the cache in milliseconds.
     * @param {string} cacheName - The cache containing the key.
     * @param {string} key - The key for which the ttl remaining is requested.
     * @param {number} ttlMilliseconds - The ttl in milliseconds that should
     * overwrite the current ttl. Should be greater than the current ttl.
     * @returns {Promise<CacheIncreaseTtl.Response>}
     * {@link CacheIncreaseTtl.Set} when the ttl was successfully increased.
     * {@link CacheIncreaseTtl.Miss} when the key does not exist.
     * {@link CacheIncreaseTtl.Error} on failure.
     */
    async increaseTtl(cacheName, key, ttlMilliseconds) {
        const client = this.getNextDataClient();
        return await client.increaseTtl(cacheName, key, ttlMilliseconds);
    }
    /**
     * Decrease the ttl of the key in the cache in milliseconds.
     * @param {string} cacheName - The cache containing the key.
     * @param {string} key - The key for which the ttl remaining is requested.
     * @param {number} ttlMilliseconds - The ttl in milliseconds that should
     * overwrite the current ttl. Should be less than the current ttl.
     * @returns {Promise<CacheDecreaseTtl.Response>}
     * {@link CacheDecreaseTtl.Set} when the ttl was successfully decreased.
     * {@link CacheDecreaseTtl.Miss} when the key does not exist.
     * {@link CacheDecreaseTtl.Error} on failure.
     */
    async decreaseTtl(cacheName, key, ttlMilliseconds) {
        const client = this.getNextDataClient();
        return await client.decreaseTtl(cacheName, key, ttlMilliseconds);
    }
    getNextDataClient() {
        const client = this.dataClients[this.nextDataClientIndex];
        this.nextDataClientIndex =
            (this.nextDataClientIndex + 1) % this.dataClients.length;
        return client;
    }
}
exports.AbstractCacheClient = AbstractCacheClient;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiQWJzdHJhY3RDYWNoZUNsaWVudC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uL3NyYy9pbnRlcm5hbC9jbGllbnRzL2NhY2hlL0Fic3RyYWN0Q2FjaGVDbGllbnQudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7O0FBQUEsMENBdUR3QjtBQXdCeEIsbURBQTZDO0FBRTdDLE1BQXNCLG1CQUFtQjtJQVN2QyxZQUNFLGFBQTZCLEVBQzdCLFdBQTBCLEVBQzFCLFVBQXdCO1FBRXhCLElBQUksQ0FBQyxhQUFhLEdBQUcsYUFBYSxDQUFDO1FBQ25DLElBQUksQ0FBQyxXQUFXLEdBQUcsV0FBVyxDQUFDO1FBQy9CLElBQUksQ0FBQyxVQUFVLEdBQUcsVUFBVSxDQUFDO1FBRTdCLDRFQUE0RTtRQUM1RSx5RUFBeUU7UUFDekUsa0JBQWtCO1FBQ2xCLElBQUksQ0FBQyxtQkFBbUIsR0FBRyxDQUFDLENBQUM7SUFDL0IsQ0FBQztJQUVNLEtBQUssQ0FBQyxTQUFpQjtRQUM1QixPQUFPLElBQUksNEJBQVksQ0FBQyxJQUFJLEVBQUUsU0FBUyxDQUFDLENBQUM7SUFDM0MsQ0FBQztJQUVEOztPQUVHO0lBQ0ksS0FBSyxDQUFDLElBQUk7O1FBQ2YsT0FBTyxNQUFNLENBQUEsTUFBQSxJQUFJLENBQUMsVUFBVSwwQ0FBRSxJQUFJLEVBQUUsQ0FBQSxDQUFDO0lBQ3ZDLENBQUM7SUFFRDs7Ozs7Ozs7T0FRRztJQUNJLEtBQUssQ0FBQyxXQUFXLENBQUMsU0FBaUI7UUFDeEMsT0FBTyxNQUFNLElBQUksQ0FBQyxhQUFhLENBQUMsV0FBVyxDQUFDLFNBQVMsQ0FBQyxDQUFDO0lBQ3pELENBQUM7SUFFRDs7Ozs7OztPQU9HO0lBQ0ksS0FBSyxDQUFDLFdBQVcsQ0FBQyxTQUFpQjtRQUN4QyxPQUFPLE1BQU0sSUFBSSxDQUFDLGFBQWEsQ0FBQyxXQUFXLENBQUMsU0FBUyxDQUFDLENBQUM7SUFDekQsQ0FBQztJQUVEOzs7Ozs7T0FNRztJQUNJ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LG1CQUFtQjtZQUN0QixDQUFDLElBQUksQ0FBQyxtQkFBbUIsR0FBRyxDQUFDLENBQUMsR0FBRyxJQUFJLENBQUMsV0FBVyxDQUFDLE1BQU0sQ0FBQztRQUMzRCxPQUFPLE1BQU0sQ0FBQztJQUNoQixDQUFDO0NBQ0Y7QUFod0NELGtEQWd3Q0MiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge1xuICBDcmVhdGVDYWNoZSxcbiAgRGVsZXRlQ2FjaGUsXG4gIExpc3RDYWNoZXMsXG4gIENhY2hlRmx1c2gsXG4gIENhY2hlR2V0LFxuICBDYWNoZVNldCxcbiAgQ2FjaGVEZWxldGUsXG4gIENhY2hlSW5jcmVtZW50LFxuICBJbmNyZW1lbnRPcHRpb25zLFxuICBDYWNoZVNldElmTm90RXhpc3RzLFxuICBTZXRJZk5vdEV4aXN0c09wdGlvbnMsXG4gIENhY2hlU2V0RmV0Y2gsXG4gIENhY2hlU2V0QWRkRWxlbWVudCxcbiAgQ2FjaGVTZXRBZGRFbGVtZW50cyxcbiAgQ2FjaGVTZXRSZW1vdmVFbGVtZW50LFxuICBDYWNoZVNldFJlbW92ZUVsZW1lbnRzLFxuICBDYWNoZUxpc3RGZXRjaCxcbiAgQ2FjaGVMaXN0TGVuZ3RoLFxuICBDYWNoZUxpc3RQdXNoRnJvbnQsXG4gIENhY2hlTGlzdFB1c2hCYWNrLFxuICBDYWNoZUxpc3RDb25jYXRlbmF0ZUJhY2ssXG4gIENhY2hlTGlzdENvbmNhdGVuYXRlRnJvbnQsXG4gIENhY2hlTGlzdFBvcEJhY2ssXG4gIENhY2hlTGlzdFBvcEZyb250LFxuICBDYWNoZUxpc3RSZW1vdmVWYWx1ZSxcbiAgQ2FjaGVMaXN0UmV0YWluLFxuICBDYWNoZURpY3Rpb25hcnlTZXRGaWVsZCxcbiAgQ2FjaGVEaWN0aW9uYXJ5U2V0RmllbGRzLFxuICBDYWNoZURpY3Rpb25hcnlHZXRGaWVsZCxcbiAgQ2FjaGVEaWN0aW9uYXJ5R2V0RmllbGRzLFxuICBDYWNoZURpY3Rpb25hcnlJbmNyZW1lbnQsXG4gIENhY2hlRGljdGlvbmFyeUZldGNoLFxuICBDYWNoZURpY3Rpb25hcnlSZW1vdmVGaWVsZCxcbiAgQ2FjaGVEaWN0aW9uYXJ5UmVtb3ZlRmllbGRzLFxuICBDYWNoZURpY3Rpb25hcnlMZW5ndGgsXG4gIENhY2hlU29ydGVkU2V0RmV0Y2gsXG4gIENhY2hlU29ydGVkU2V0UHV0RWxlbWVudCxcbiAgQ2FjaGVTb3J0ZWRTZXRQdXRFbGVtZW50cyxcbiAgQ2FjaGVTb3J0ZWRTZXRHZXRSYW5rLFxuICBDYWNoZVNvcnRlZFNldEdldFNjb3JlLFxuICBDYWNoZVNvcnRlZFNldEdldFNjb3JlcyxcbiAgQ2FjaGVTb3J0ZWRTZXRJbmNyZW1lbnRTY29yZSxcbiAgQ2FjaGVTb3J0ZWRTZXRSZW1vdmVFbGVtZW50LFxuICBDYWNoZVNvcnRlZFNldFJlbW92ZUVsZW1lbnRzLFxuICBDYWNoZVNvcnRlZFNldExlbmd0aCxcbiAgQ2FjaGVTb3J0ZWRTZXRMZW5ndGhCeVNjb3JlLFxuICBTb3J0ZWRTZXRPcmRlcixcbiAgQ2FjaGVJdGVtR2V0VHRsLFxuICBDYWNoZUl0ZW1HZXRUeXBlLFxuICBDYWNoZUtleUV4aXN0cyxcbiAgQ2FjaGVLZXlzRXhpc3QsXG4gIENhY2hlVXBkYXRlVHRsLFxuICBDYWNoZUluY3JlYXNlVHRsLFxuICBDYWNoZURlY3JlYXNlVHRsLFxufSBmcm9tICcuLi8uLi8uLi9pbmRleCc7XG5pbXBvcnQge0xpc3RGZXRjaENhbGxPcHRpb25zLCBMaXN0UmV0YWluQ2FsbE9wdGlvbnN9IGZyb20gJy4uLy4uLy4uL3V0aWxzJztcbmltcG9ydCB7XG4gIElDYWNoZUNsaWVudCxcbiAgU2V0T3B0aW9ucyxcbiAgU2V0QWRkRWxlbWVudE9wdGlvbnMsXG4gIFNldEFkZEVsZW1lbnRzT3B0aW9ucyxcbiAgTGlzdFB1c2hGcm9udE9wdGlvbnMsXG4gIExpc3RQdXNoQmFja09wdGlvbnMsXG4gIExpc3RDb25jYXRlbmF0ZUJhY2tPcHRpb25zLFxuICBMaXN0Q29uY2F0ZW5hdGVGcm9udE9wdGlvbnMsXG4gIERpY3Rpb25hcnlTZXRGaWVsZE9wdGlvbnMsXG4gIERpY3Rpb25hcnlJbmNyZW1lbnRPcHRpb25zLFxuICBTb3J0ZWRTZXRGZXRjaEJ5UmFua09wdGlvbnMsXG4gIFNvcnRlZFNldFB1dEVsZW1lbnRPcHRpb25zLFxuICBTb3J0ZWRTZXRQdXRFbGVtZW50c09wdGlvbnMsXG4gIFNvcnRlZFNldEZldGNoQnlTY29yZU9wdGlvbnMsXG4gIFNvcnRlZFNldEluY3JlbWVudE9wdGlvbnMsXG4gIFNvcnRlZFNldExlbmd0aEJ5U2NvcmVPcHRpb25zLFxufSBmcm9tICcuLi8uLi8uLi9jbGllbnRzL0lDYWNoZUNsaWVudCc7XG5pbXBvcnQge0lDb250cm9sQ2xpZW50fSBmcm9tICcuL0lDb250cm9sQ2xpZW50JztcbmltcG9ydCB7SURhdGFDbGllbnR9IGZyb20gJy4vSURhdGFDbGllbnQnO1xuaW1wb3J0IHtJUGluZ0NsaWVudH0gZnJvbSAnLi9JUGluZ0NsaWVudCc7XG5pbXBvcnQge0lNb21lbnRvQ2FjaGV9IGZyb20gJy4uLy4uLy4uL2NsaWVudHMvSU1vbWVudG9DYWNoZSc7XG5pbXBvcnQge01vbWVudG9DYWNoZX0gZnJvbSAnLi9tb21lbnRvLWNhY2hlJztcblxuZXhwb3J0IGFic3RyYWN0IGNsYXNzIEFic3RyYWN0Q2FjaGVDbGllbnQgaW1wbGVtZW50cyBJQ2FjaGVDbGllbnQge1xuICAvLyBtYWtpbmcgdGhlc2UgcHJvdGVjdGVkIHVudGlsIHdlIGZ1bGx5IGFic3RyYWN0IGF3YXkgdGhlIG5vZGVqcyBjbGllbnRcbiAgcHJvdGVjdGVkIHJlYWRvbmx5IGNvbnRyb2xDbGllbnQ6IElDb250cm9sQ2xpZW50O1xuICBwcm90ZWN0ZWQgcmVhZG9ubHkgZGF0YUNsaWVudHM6IElEYXRhQ2xpZW50W107XG4gIC8vIFRPRE86IE1ha2UgcGluZ0NsaWVudCByZXF1aXJlZCBpZiBhbmQgd2hlbiB0aGUgbm9kZWpzIHNpZGUgc3RhcnRzIGFkZGluZ1xuICAvLyAgb25lIGFzIHdlbGxcbiAgcHJvdGVjdGVkIHJlYWRvbmx5IHBpbmdDbGllbnQ/OiBJUGluZ0NsaWVudDtcbiAgcHJvdGVjdGVkIG5leHREYXRhQ2xpZW50SW5kZXg6IG51bWJlcjtcblxuICBwcm90ZWN0ZWQgY29uc3RydWN0b3IoXG4gICAgY29udHJvbENsaWVudDogSUNvbnRyb2xDbGllbnQsXG4gICAgZGF0YUNsaWVudHM6IElEYXRhQ2xpZW50W10sXG4gICAgcGluZ0NsaWVudD86IElQaW5nQ2xpZW50XG4gICkge1xuICAgIHRoaXMuY29udHJvbENsaWVudCA9IGNvbnRyb2xDbGllbnQ7XG4gICAgdGhpcy5kYXRhQ2xpZW50cyA9IGRhdGFDbGllbnRzO1xuICAgIHRoaXMucGluZ0NsaWVudCA9IHBpbmdDbGllbnQ7XG5cbiAgICAvLyBXZSByb3VuZC1yb2JpbiB0aGUgcmVxdWVzdHMgdGhyb3VnaCBhbGwgb2Ygb3VyIGNsaWVudHMuICBTaW5jZSBqYXZhc2NyaXB0XG4gICAgLy8gaXMgc2luZ2xlLXRocmVhZGVkLCB3ZSBkb24ndCBoYXZlIHRvIHdvcnJ5IGFib3V0IHRocmVhZCBzYWZldHkgb24gdGhpc1xuICAgIC8vIGluZGV4IHZhcmlhYmxlLlxuICAgIHRoaXMubmV4dERhdGFDbGllbnRJbmRleCA9IDA7XG4gIH1cblxuICBwdWJsaWMgY2FjaGUoY2FjaGVOYW1lOiBzdHJpbmcpOiBJTW9tZW50b0NhY2hlIHtcbiAgICByZXR1cm4gbmV3IE1vbWVudG9DYWNoZSh0aGlzLCBjYWNoZU5hbWUpO1xuICB9XG5cbiAgLyoqXG4gICAqIFBpbmcgdGhlIHNlcnZpY2UgdG8gdmVyaWZ5IGl0IGlzIHVwIGFuZCBydW5uaW5nXG4gICAqL1xuICBwdWJsaWMgYXN5bmMgcGluZygpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICByZXR1cm4gYXdhaXQgdGhpcy5waW5nQ2xpZW50Py5waW5nKCk7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlcyBhIGNhY2hlIGlmIGl0IGRvZXMgbm90IGV4aXN0LlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gY2FjaGVOYW1lIC0gVGhlIGNhY2hlIHRvIGJlIGNyZWF0ZWQuXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPENyZWF0ZUNhY2hlLlJlc3BvbnNlPn0gLVxuICAgKiB7QGxpbmsgQ3JlYXRlQ2FjaGUuU3VjY2Vzc30gb24gc3VjY2Vzcy5cbiAgICoge0BsaW5rIENyZWF0ZUNhY2hlLkFscmVhZHlFeGlzdHN9IGlmIHRoZSBjYWNoZSBhbHJlYWR5IGV4aXN0cy5cbiAgICoge0BsaW5rIENyZWF0ZUNhY2hlLkVycm9yfSBvbiBmYWlsdXJlLlxuICAgKi9cbiAgcHVibGljIGFzeW5jIGNyZWF0ZUNhY2hlKGNhY2hlTmFtZTogc3RyaW5nKTogUHJvbWlzZTxDcmVhdGVDYWNoZS5SZXNwb25zZT4ge1xuICAgIHJldHVybiBhd2FpdCB0aGlzLmNvbnRyb2xDbGllbnQuY3JlYXRlQ2FjaGUoY2FjaGVOYW1lKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEZWxldGVzIGEgY2FjaGUgYW5kIGFsbCBpdGVtcyBzdG9yZWQgaW4gaXQuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBjYWNoZU5hbWUgLSBUaGUgY2FjaGUgdG8gZGVsZXRlLlxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxEZWxldGVDYWNoZS5SZXNwb25zZT59IC1cbiAgICoge0BsaW5rIERlbGV0ZUNhY2hlLlN1Y2Nlc3N9IG9uIHN1Y2Nlc3MuXG4gICAqIHtAbGluayBEZWxldGVDYWNoZS5FcnJvcn0gb24gZmFpbHVyZS5cbiAgICovXG4gIHB1YmxpYyBhc3luYyBkZWxldGVDYWNoZShjYWNoZU5hbWU6IHN0cmluZyk6IFByb21pc2U8RGVsZXRlQ2FjaGUuUmVzcG9uc2U+IHtcbiAgICByZXR1cm4gYXdhaXQgdGhpcy5jb250cm9sQ2xpZW50LmRlbGV0ZUNhY2hlKGNhY2hlTmFtZSk7XG4gIH1cblxuICAvKipcbiAgICogTGlzdHMgYWxsIGNhY2hlcy5cbiAgICpcbiAgICogQHJldHVybnMge1Byb21pc2U8TGlzdENhY2hlcy5SZXNwb25zZT59IC1cbiAgICoge0BsaW5rIExpc3RDYWNoZXMuU3VjY2Vzc30gY29udGFpbmluZyB0aGUgbGlzdCBvbiBzdWNjZXNzLlxuICAgKiB7QGxpbmsgTGlzdENhY2hlcy5FcnJvcn0gb24gZmFpbHVyZS5cbiAgICovXG4gIHB1YmxpYyBhc3luYyBsaXN0Q2FjaGVzKCk6IFByb21pc2U8TGlzdENhY2hlcy5SZXNwb25zZT4ge1xuICAgIHJldHVybiBhd2FpdCB0aGlzLmNvbnRyb2xDbGllbnQubGlzdENhY2hlcygpO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgdGhlIHZhbHVlIHN0b3JlZCBmb3IgdGhlIGdpdmVuIGtleS5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IGNhY2hlTmFtZSAtIFRoZSBjYWNoZSB0byBwZXJmb3JtIHRoZSBsb29rdXAgaW4uXG4gICAqIEBwYXJhbSB7c3RyaW5nIHwgVWludDhBcnJheX0ga2V5IC0gVGhlIGtleSB0byBsb29rIHVwLlxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxDYWNoZUdldC5SZXNwb25zZT59IC1cbiAgICoge0BsaW5rIENhY2hlR2V0LkhpdH0gY29udGFpbmluZyB0aGUgdmFsdWUgaWYgb25lIGlzIGZvdW5kLlxuICAgKiB7QGxpbmsgQ2FjaGVHZXQuTWlzc30gaWYgdGhlIGtleSBkb2VzIG5vdCBleGlzdC5cbiAgICoge0BsaW5rIENhY2hlR2V0LkVycm9yfSBvbiBmYWlsdXJlLlxuICAgKi9cbiAgcHVibGljIGFzeW5jIGdldChcbiAgICBjYWNoZU5hbWU6IHN0cmluZyxcbiAgICBrZXk6IHN0cmluZyB8IFVpbnQ4QXJyYXlcbiAgKTogUHJvbWlzZTxDYWNoZUdldC5SZXNwb25zZT4ge1xuICAgIHJldHVybiBhd2FpdCB0aGlzLmdldE5leHREYXRhQ2xpZW50KCkuZ2V0KGNhY2hlTmFtZSwga2V5KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBc3NvY2lhdGVzIHRoZSBnaXZlbiBrZXkgd2l0aCB0aGUgZ2l2ZW4gdmFsdWUuIElmIGEgdmFsdWUgZm9yIHRoZSBrZXkgaXNcbiAgICogYWxyZWFkeSBwcmVzZW50IGl0IGlzIHJlcGxhY2VkIHdpdGggdGhlIG5ldyB2YWx1ZS5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IGNhY2hlTmFtZSAtIFRoZSBjYWNoZSB0byBzdG9yZSB0aGUgdmFsdWUgaW4uXG4gICAqIEBwYXJhbSB7c3RyaW5nIHwgVWludDhBcnJheX0ga2V5IC0gVGhlIGtleSB0byBzZXQuXG4gICAqIEBwYXJhbSB7c3RyaW5nIHwgVWludDhBcnJheX0gdmFsdWUgLSBUaGUgdmFsdWUgdG8gYmUgc3RvcmVkLlxuICAgKiBAcGFyYW0ge1NldE9wdGlvbnN9IFtvcHRpb25zXVxuICAgKiBAcGFyYW0ge251bWJlcn0gW29wdGlvbnMudHRsXSAtIFRoZSB0aW1lIHRvIGxpdmUgZm9yIHRoZSBpdGVtIGluIHRoZSBjYWNoZS5cbiAgICogVXNlcyB0aGUgY2xpZW50J3MgZGVmYXVsdCBUVEwgaWYgdGhpcyBpcyBub3Qgc3VwcGxpZWQuXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPENhY2hlU2V0LlJlc3BvbnNlPn0gLVxuICAgKiB7QGxpbmsgQ2FjaGVTZXQuU3VjY2Vzc30gb24gc3VjY2Vzcy5cbiAgICoge0BsaW5rIENhY2hlU2V0LkVycm9yfSBvbiBmYWlsdXJlLlxuICAgKi9cbiAgcHVibGljIGFzeW5jIHNldChcbiAgICBjYWNoZU5hbWU6IHN0cmluZyxcbiAgICBrZXk6IHN0cmluZyB8IFVpbnQ4QXJyYXksXG4gICAgdmFsdWU6IHN0cmluZyB8IFVpbnQ4QXJyYXksXG4gICAgb3B0aW9ucz86IFNldE9wdGlvbnNcbiAgKTogUHJvbWlzZTxDYWNoZVNldC5SZXNwb25zZT4ge1xuICAgIGNvbnN0IGNsaWVudCA9IHRoaXMuZ2V0TmV4dERhdGFDbGllbnQoKTtcbiAgICByZXR1cm4gYXdhaXQgY2xpZW50LnNldChjYWNoZU5hbWUsIGtleSwgdmFsdWUsIG9wdGlvbnM/LnR0bCk7XG4gIH1cblxuICAvKipcbiAgICogUmVtb3ZlcyB0aGUgZ2l2ZW4ga2V5IGZyb20gdGhlIGNhY2hlLiBUaGUga2V5IGNhbiByZXByZXNlbnQgYSBzaW5nbGUgdmFsdWVcbiAgICogb3IgYSBjb2xsZWN0aW9uLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gY2FjaGVOYW1lIC0gVGhlIGNhY2hlIHRvIGRlbGV0ZSBmcm9tLlxuICAgKiBAcGFyYW0ge3N0cmluZyB8IFVpbnQ4QXJyYXl9IGtleSAtIFRoZSBrZXkgdG8gZGVsZXRlLlxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxDYWNoZURlbGV0ZS5SZXNwb25zZT59IC1cbiAgICoge0BsaW5rIENhY2hlRGVsZXRlLlN1Y2Nlc3N9IG9uIHN1Y2Nlc3MuXG4gICAqIHtAbGluayBDYWNoZURlbGV0ZS5FcnJvcn0gb24gZmFpbHVyZS5cbiAgICovXG4gIHB1YmxpYyBhc3luYyBkZWxldGUoXG4gICAgY2FjaGVOYW1lOiBzdHJpbmcsXG4gICAga2V5OiBzdHJpbmcgfCBVaW50OEFycmF5XG4gICk6IFByb21pc2U8Q2FjaGVEZWxldGUuUmVzcG9uc2U+IHtcbiAgICBjb25zdCBjbGllbnQgPSB0aGlzLmdldE5leHREYXRhQ2xpZW50KCk7XG4gICAgcmV0dXJuIGF3YWl0IGNsaWVudC5kZWxldGUoY2FjaGVOYW1lLCBrZXkpO1xuICB9XG5cbiAgLyoqXG4gICAqIEFkZHMgbXVsdGlwbGUgZWxlbWVudHMgdG8gdGhlIGJhY2sgb2YgdGhlIGdpdmVuIGxpc3QuIENyZWF0ZXMgdGhlIGxpc3QgaWZcbiAgICogaXQgZG9lcyBub3QgYWxyZWFkeSBleGlzdC5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IGNhY2hlTmFtZSAtIFRoZSBjYWNoZSB0byBzdG9yZSB0aGUgbGlzdCBpbi5cbiAgICogQHBhcmFtIHtzdHJpbmd9IGxpc3ROYW1lIC0gVGhlIGxpc3QgdG8gYWRkIHRvLlxuICAgKiBAcGFyYW0ge3N0cmluZ1tdIHwgVWludDhBcnJheVtdfSB2YWx1ZXMgLSBUaGUgZWxlbWVudHMgdG8gYWRkIHRvIHRoZSBsaXN0LlxuICAgKiBAcGFyYW0ge0xpc3RDb25jYXRlbmF0ZUJhY2tPcHRpb25zfSBbb3B0aW9uc11cbiAgICogQHBhcmFtIHtudW1iZXJ9IFtvcHRpb25zLnRydW5jYXRlRnJvbnRUb1NpemVdIC0gSWYgdGhlIGxpc3QgZXhjZWVkcyB0aGlzXG4gICAqIGxlbmd0aCwgcmVtb3ZlIGV4Y2VzcyBmcm9tIHRoZSBmcm9udCBvZiB0aGUgbGlzdC4gTXVzdCBiZSBwb3NpdGl2ZS5cbiAgICogQHBhcmFtIHtDb2xsZWN0aW9uVHRsfSBbb3B0aW9ucy50dGxdIC0gSG93IHRoZSBUVEwgc2hvdWxkIGJlIG1hbmFnZWQuXG4gICAqIFJlZnJlc2hlcyB0aGUgbGlzdCdzIFRUTCB1c2luZyB0aGUgY2xpZW50J3MgZGVmYXVsdCBpZiB0aGlzIGlzIG5vdFxuICAgKiBzdXBwbGllZC5cbiAgICogQHJldHVybnMge1Byb21pc2U8Q2FjaGVMaXN0Q29uY2F0ZW5hdGVCYWNrLlJlc3BvbnNlPn0gLVxuICAgKiB7QGxpbmsgQ2FjaGVMaXN0Q29uY2F0ZW5hdGVCYWNrLlN1Y2Nlc3N9IG9uIHN1Y2Nlc3MuXG4gICAqIHtAbGluayBDYWNoZUxpc3RDb25jYXRlbmF0ZUJhY2suRXJyb3J9IG9uIGZhaWx1cmUuXG4gICAqL1xuICBwdWJsaWMgYXN5bmMgbGlzdENvbmNhdGVuYXRlQmFjayhcbiAgICBjYWNoZU5hbWU6IHN0cmluZyxcbiAgICBsaXN0TmFtZTogc3RyaW5nLFxuICAgIHZhbHVlczogc3RyaW5nW10gfCBVaW50OEFycmF5W10sXG4gICAgb3B0aW9ucz86IExpc3RDb25jYXRlbmF0ZUJhY2tPcHRpb25zXG4gICk6IFByb21pc2U8Q2FjaGVMaXN0Q29uY2F0ZW5hdGVCYWNrLlJlc3BvbnNlPiB7XG4gICAgY29uc3QgY2xpZW50ID0gdGhpcy5nZXROZXh0RGF0YUNsaWVudCgpO1xuICAgIHJldHVybiBhd2FpdCBjbGllbnQubGlzdENvbmNhdGVuYXRlQmFjayhcbiAgICAgIGNhY2hlTmFtZSxcbiAgICAgIGxpc3ROYW1lLFxuICAgICAgdmFsdWVzLFxuICAgICAgb3B0aW9ucz8udHJ1bmNhdGVGcm9udFRvU2l6ZSxcbiAgICAgIG9wdGlvbnM/LnR0bFxuICAgICk7XG4gIH1cblxuICAvKipcbiAgICogQWRkcyBtdWx0aXBsZSBlbGVtZW50cyB0byB0aGUgZnJvbnQgb2YgdGhlIGdpdmVuIGxpc3QuIENyZWF0ZXMgdGhlIGxpc3QgaWZcbiAgICogaXQgZG9lcyBub3QgYWxyZWFkeSBleGlzdC5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IGNhY2hlTmFtZSAtIFRoZSBjYWNoZSB0byBzdG9yZSB0aGUgbGlzdCBpbi5cbiAgICogQHBhcmFtIHtzdHJpbmd9IGxpc3ROYW1lIC0gVGhlIGxpc3QgdG8gYWRkIHRvLlxuICAgKiBAcGFyYW0ge3N0cmluZ1tdIHwgVWludDhBcnJheVtdfSB2YWx1ZXMgLSBUaGUgZWxlbWVudHMgdG8gYWRkIHRvIHRoZSBsaXN0LlxuICAgKiBAcGFyYW0ge0xpc3RDb25jYXRlbmF0ZUZyb250T3B0aW9uc30gW29wdGlvbnNdXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0aW9ucy50cnVuY2F0ZUJhY2tUb1NpemVdIC0gSWYgdGhlIGxpc3QgZXhjZWVkcyB0aGlzXG4gICAqIGxlbmd0aCwgcmVtb3ZlIGV4Y2VzcyBmcm9tIHRoZSBiYWNrIG9mIHRoZSBsaXN0LiBNdXN0IGJlIHBvc2l0aXZlLlxuICAgKiBAcGFyYW0ge0NvbGxlY3Rpb25UdGx9IFtvcHRpb25zLnR0bF0gLSBIb3cgdGhlIFRUTCBzaG91bGQgYmUgbWFuYWdlZC5cbiAgICogUmVmcmVzaGVzIHRoZSBsaXN0J3MgVFRMIHVzaW5nIHRoZSBjbGllbnQncyBkZWZhdWx0IGlmIHRoaXMgaXMgbm90XG4gICAqIHN1cHBsaWVkLlxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxDYWNoZUxpc3RDb25jYXRlbmF0ZUZyb250LlJlc3BvbnNlPn0gLVxuICAgKiB7QGxpbmsgQ2FjaGVMaXN0Q29uY2F0ZW5hdGVGcm9udC5TdWNjZXNzfSBvbiBzdWNjZXNzLlxuICAgKiB7QGxpbmsgQ2FjaGVMaXN0Q29uY2F0ZW5hdGVGcm9udC5FcnJvcn0gb24gZmFpbHVyZS5cbiAgICovXG4gIHB1YmxpYyBhc3luYyBsaXN0Q29uY2F0ZW5hdGVGcm9udChcbiAgICBjYWNoZU5hbWU6IHN0cmluZyxcbiAgICBsaXN0TmFtZTogc3RyaW5nLFxuICAgIHZhbHVlczogc3RyaW5nW10gfCBVaW50OEFycmF5W10sXG4gICAgb3B0aW9ucz86IExpc3RDb25jYXRlbmF0ZUZyb250T3B0aW9uc1xuICApOiBQcm9taXNlPENhY2hlTGlzdENvbmNhdGVuYXRlRnJvbnQuUmVzcG9uc2U+IHtcbiAgICBjb25zdCBjbGllbnQgPSB0aGlzLmdldE5leHREYXRhQ2xpZW50KCk7XG4gICAgcmV0dXJuIGF3YWl0IGNsaWVudC5saXN0Q29uY2F0ZW5hdGVGcm9udChcbiAgICAgIGNhY2hlTmFtZSxcbiAgICAgIGxpc3ROYW1lLFxuICAgICAgdmFsdWVzLFxuICAgICAgb3B0aW9ucz8udHJ1bmNhdGVCYWNrVG9TaXplLFxuICAgICAgb3B0aW9ucz8udHRsXG4gICAgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBGZXRjaGVzIGFsbCBlbGVtZW50cyBvZiB0aGUgZ2l2ZW4gbGlzdC5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IGNhY2hlTmFtZSAtIFRoZSBjYWNoZSBjb250YWluaW5nIHRoZSBsaXN0LlxuICAgKiBAcGFyYW0ge3N0cmluZ30gbGlzdE5hbWUgLSBUaGUgbGlzdCB0byBmZXRjaC5cbiAgICogQHBhcmFtIHtMaXN0RmV0Y2hDYWxsT3B0aW9uc30gW29wdGlvbnNdXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0aW9ucy5zdGFydEluZGV4XSAtIFN0YXJ0IGluY2x1c2l2ZSBpbmRleCBmb3IgZmV0Y2ggb3BlcmF0aW9uLlxuICAgKiBAcGFyYW0ge251bWJlcn0gW29wdGlvbnMuZW5kSW5kZXhdIC0gRW5kIGV4Y2x1c2l2ZSBpbmRleCBmb3IgZmV0Y2ggb3BlcmF0aW9uLlxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxDYWNoZUxpc3RGZXRjaC5SZXNwb25zZT59IC1cbiAgICoge0BsaW5rIENhY2hlTGlzdEZldGNoLkhpdH0gY29udGFpbmluZyB0aGUgbGlzdCBlbGVtZW50cyBpZiB0aGUgbGlzdCBleGlzdHMuXG4gICAqIHtAbGluayBDYWNoZUxpc3RGZXRjaC5NaXNzfSBpZiB0aGUgbGlzdCBkb2VzIG5vdCBleGlzdC5cbiAgICoge0BsaW5rIENhY2hlTGlzdEZldGNoLkVycm9yfSBvbiBmYWlsdXJlLlxuICAgKi9cbiAgcHVibGljIGFzeW5jIGxpc3RGZXRjaChcbiAgICBjYWNoZU5hbWU6IHN0cmluZyxcbiAgICBsaXN0TmFtZTogc3RyaW5nLFxuICAgIG9wdGlvbnM/OiBMaXN0RmV0Y2hDYWxsT3B0aW9uc1xuICApOiBQcm9taXNlPENhY2hlTGlzdEZldGNoLlJlc3BvbnNlPiB7XG4gICAgY29uc3QgY2xpZW50ID0gdGhpcy5nZXROZXh0RGF0YUNsaWVudCgpO1xuICAgIHJldHVybiBhd2FpdCBjbGllbnQubGlzdEZldGNoKFxuICAgICAgY2FjaGVOYW1lLFxuICAgICAgbGlzdE5hbWUsXG4gICAgICBvcHRpb25zPy5zdGFydEluZGV4LFxuICAgICAgb3B0aW9ucz8uZW5kSW5kZXhcbiAgICApO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgdGhlIG51bWJlciBvZiBlbGVtZW50cyBpbiB0aGUgZ2l2ZW4gbGlzdC5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IGNhY2hlTmFtZSAtIFRoZSBjYWNoZSBjb250YWluaW5nIHRoZSBsaXN0LlxuICAgKiBAcGFyYW0ge3N0cmluZ30gbGlzdE5hbWUgLSBUaGUgbGlzdCB0byBnZXQgdGhlIGxlbmd0aCBvZi5cbiAgICogQHJldHVybnMge1Byb21pc2U8Q2FjaGVMaXN0TGVuZ3RoLlJlc3BvbnNlPn0gLVxuICAgKiB7QGxpbmsgQ2FjaGVMaXN0TGVuZ3RoLkhpdH0gY29udGFpbmluZyB0aGUgbGVuZ3RoIGlmIHRoZSBsaXN0IGV4aXN0cy5cbiAgICoge0BsaW5rIENhY2hlTGlzdExlbmd0aC5NaXNzfSBpZiB0aGUgbGlzdCBkb2VzIG5vdCBleGlzdC5cbiAgICoge0BsaW5rIENhY2hlTGlzdExlbmd0aC5FcnJvcn0gb24gZmFpbHVyZS5cbiAgICovXG4gIHB1YmxpYyBhc3luYyBsaXN0TGVuZ3RoKFxuICAgIGNhY2hlTmFtZTogc3RyaW5nLFxuICAgIGxpc3ROYW1lOiBzdHJpbmdcbiAgKTogUHJvbWlzZTxDYWNoZUxpc3RMZW5ndGguUmVzcG9uc2U+IHtcbiAgICBjb25zdCBjbGllbnQgPSB0aGlzLmdldE5leHREYXRhQ2xpZW50KCk7XG4gICAgcmV0dXJuIGF3YWl0IGNsaWVudC5saXN0TGVuZ3RoKGNhY2hlTmFtZSwgbGlzdE5hbWUpO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgYW5kIHJlbW92ZXMgdGhlIGxhc3QgdmFsdWUgZnJvbSB0aGUgZ2l2ZW4gbGlzdC5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IGNhY2hlTmFtZSAtIFRoZSBjYWNoZSBjb250YWluaW5nIHRoZSBsaXN0LlxuICAgKiBAcGFyYW0ge3N0cmluZ30gbGlzdE5hbWUgLSBUaGUgbGlzdCB0byBwb3AuXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPENhY2hlTGlzdFBvcEJhY2suUmVzcG9uc2U+fSAtXG4gICAqIHtAbGluayBDYWNoZUxpc3RQb3BCYWNrLkhpdH0gY29udGFpbmluZyB0aGUgZWxlbWVudCBpZiB0aGUgbGlzdCBleGlzdHMuXG4gICAqIHtAbGluayBDYWNoZUxpc3RQb3BCYWNrLk1pc3N9IGlmIHRoZSBsaXN0IGRvZXMgbm90IGV4aXN0LlxuICAgKiB7QGxpbmsgQ2FjaGVMaXN0UG9wQmFjay5FcnJvcn0gb24gZmFpbHVyZS5cbiAgICovXG4gIHB1YmxpYyBhc3luYyBsaXN0UG9wQmFjayhcbiAgICBjYWNoZU5hbWU6IHN0cmluZyxcbiAgICBsaXN0TmFtZTogc3RyaW5nXG4gICk6IFByb21pc2U8Q2FjaGVMaXN0UG9wQmFjay5SZXNwb25zZT4ge1xuICAgIGNvbnN0IGNsaWVudCA9IHRoaXMuZ2V0TmV4dERhdGFDbGllbnQoKTtcbiAgICByZXR1cm4gYXdhaXQgY2xpZW50Lmxpc3RQb3BCYWNrKGNhY2hlTmFtZSwgbGlzdE5hbWUpO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgYW5kIHJlbW92ZXMgdGhlIGZpcnN0IHZhbHVlIGZyb20gdGhlIGdpdmVuIGxpc3QuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBjYWNoZU5hbWUgLSBUaGUgY2FjaGUgY29udGFpbmluZyB0aGUgbGlzdC5cbiAgICogQHBhcmFtIHtzdHJpbmd9IGxpc3ROYW1lIC0gVGhlIGxpc3QgdG8gcG9wLlxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxDYWNoZUxpc3RQb3BGcm9udC5SZXNwb25zZT59IC1cbiAgICoge0BsaW5rIENhY2hlTGlzdFBvcEZyb250LkhpdH0gY29udGFpbmluZyB0aGUgZWxlbWVudCBpZiB0aGUgbGlzdCBleGlzdHMuXG4gICAqIHtAbGluayBDYWNoZUxpc3RQb3BGcm9udC5NaXNzfSBpZiB0aGUgbGlzdCBkb2VzIG5vdCBleGlzdC5cbiAgICoge0BsaW5rIENhY2hlTGlzdFBvcEZyb250LkVycm9yfSBvbiBmYWlsdXJlLlxuICAgKi9cbiAgcHVibGljIGFzeW5jIGxpc3RQb3BGcm9udChcbiAgICBjYWNoZU5hbWU6IHN0cmluZyxcbiAgICBsaXN0TmFtZTogc3RyaW5nXG4gICk6IFByb21pc2U8Q2FjaGVMaXN0UG9wRnJvbnQuUmVzcG9uc2U+IHtcbiAgICBjb25zdCBjbGllbnQgPSB0aGlzLmdldE5leHREYXRhQ2xpZW50KCk7XG4gICAgcmV0dXJuIGF3YWl0IGNsaWVudC5saXN0UG9wRnJvbnQoY2FjaGVOYW1lLCBsaXN0TmFtZSk7XG4gIH1cblxuICAvKipcbiAgICogQWRkcyBhbiBlbGVtZW50IHRvIHRoZSBiYWNrIG9mIHRoZSBnaXZlbiBsaXN0LiBDcmVhdGVzIHRoZSBsaXN0IGlmXG4gICAqIGl0IGRvZXMgbm90IGFscmVhZHkgZXhpc3QuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBjYWNoZU5hbWUgLSBUaGUgY2FjaGUgdG8gc3RvcmUgdGhlIGxpc3QgaW4uXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBsaXN0TmFtZSAtIFRoZSBsaXN0IHRvIHB1c2ggdG8uXG4gICAqIEBwYXJhbSB7c3RyaW5nIHwgVWludDhBcnJheX0gdmFsdWUgLSBUaGUgdmFsdWUgdG8gcHVzaC5cbiAgICogQHBhcmFtIHtMaXN0UHVzaEJhY2tPcHRpb25zfSBbb3B0aW9uc11cbiAgICogQHBhcmFtIHtudW1iZXJ9IFtvcHRpb25zLnRydW5jYXRlRnJvbnRUb1NpemVdIC0gSWYgdGhlIGxpc3QgZXhjZWVkcyB0aGlzXG4gICAqIGxlbmd0aCwgcmVtb3ZlIGV4Y2VzcyBmcm9tIHRoZSBmcm9udCBvZiB0aGUgbGlzdC4gTXVzdCBiZSBwb3NpdGl2ZS5cbiAgICogQHBhcmFtIHtDb2xsZWN0aW9uVHRsfSBbb3B0aW9ucy50dGxdIC0gSG93IHRoZSBUVEwgc2hvdWxkIGJlIG1hbmFnZWQuXG4gICAqIFJlZnJlc2hlcyB0aGUgbGlzdCdzIFRUTCB1c2luZyB0aGUgY2xpZW50J3MgZGVmYXVsdCBpZiB0aGlzIGlzIG5vdFxuICAgKiBzdXBwbGllZC5cbiAgICogQHJldHVybnMge1Byb21pc2U8Q2FjaGVMaXN0UHVzaEJhY2suUmVzcG9uc2U+fSAtXG4gICAqIHtAbGluayBDYWNoZUxpc3RQdXNoQmFjay5TdWNjZXNzfSBjb250YWluaW5nIHRoZSBsaXN0J3MgbmV3IGxlbmd0aCBvblxuICAgKiBzdWNjZXNzLlxuICAgKiB7QGxpbmsgQ2FjaGVMaXN0UHVzaEJhY2suRXJyb3J9IG9uIGZhaWx1cmUuXG4gICAqL1xuICBwdWJsaWMgYXN5bmMgbGlzdFB1c2hCYWNrKFxuICAgIGNhY2hlTmFtZTogc3RyaW5nLFxuICAgIGxpc3ROYW1lOiBzdHJpbmcsXG4gICAgdmFsdWU6IHN0cmluZyB8IFVpbnQ4QXJyYXksXG4gICAgb3B0aW9ucz86IExpc3RQdXNoQmFja09wdGlvbnNcbiAgKTogUHJvbWlzZTxDYWNoZUxpc3RQdXNoQmFjay5SZXNwb25zZT4ge1xuICAgIGNvbnN0IGNsaWVudCA9IHRoaXMuZ2V0TmV4dERhdGFDbGllbnQoKTtcbiAgICByZXR1cm4gYXdhaXQgY2xpZW50Lmxpc3RQdXNoQmFjayhcbiAgICAgIGNhY2hlTmFtZSxcbiAgICAgIGxpc3ROYW1lLFxuICAgICAgdmFsdWUsXG4gICAgICBvcHRpb25zPy50cnVuY2F0ZUZyb250VG9TaXplLFxuICAgICAgb3B0aW9ucz8udHRsXG4gICAgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBZGRzIGFuIGVsZW1lbnQgdG8gdGhlIGZyb250IG9mIHRoZSBnaXZlbiBsaXN0LiBDcmVhdGVzIHRoZSBsaXN0IGlmXG4gICAqIGl0IGRvZXMgbm90IGFscmVhZHkgZXhpc3QuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBjYWNoZU5hbWUgLSBUaGUgY2FjaGUgdG8gc3RvcmUgdGhlIGxpc3QgaW4uXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBsaXN0TmFtZSAtIFRoZSBsaXN0IHRvIHB1c2ggdG8uXG4gICAqIEBwYXJhbSB7c3RyaW5nIHwgVWludDhBcnJheX0gdmFsdWUgLSBUaGUgdmFsdWUgdG8gcHVzaC5cbiAgICogQHBhcmFtIHtMaXN0UHVzaEZyb250T3B0aW9uc30gW29wdGlvbnNdXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0aW9ucy50cnVuY2F0ZUJhY2tUb1NpemVdIC0gSWYgdGhlIGxpc3QgZXhjZWVkcyB0aGlzXG4gICAqIGxlbmd0aCwgcmVtb3ZlIGV4Y2VzcyBmcm9tIHRoZSBlbmQgb2YgdGhlIGxpc3QuIE11c3QgYmUgcG9zaXRpdmUuXG4gICAqIEBwYXJhbSB7Q29sbGVjdGlvblR0bH0gW29wdGlvbnMudHRsXSAtIEhvdyB0aGUgVFRMIHNob3VsZCBiZSBtYW5hZ2VkLlxuICAgKiBSZWZyZXNoZXMgdGhlIGxpc3QncyBUVEwgdXNpbmcgdGhlIGNsaWVudCdzIGRlZmF1bHQgaWYgdGhpcyBpcyBub3RcbiAgICogc3VwcGxpZWQuXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPENhY2hlTGlzdFB1c2hGcm9udC5SZXNwb25zZT59IC1cbiAgICoge0BsaW5rIENhY2hlTGlzdFB1c2hGcm9udC5TdWNjZXNzfSBjb250YWluaW5nIHRoZSBsaXN0J3MgbmV3IGxlbmd0aCBvblxuICAgKiBzdWNjZXNzLlxuICAgKiB7QGxpbmsgQ2FjaGVMaXN0UHVzaEZyb250LkVycm9yfSBvbiBmYWlsdXJlLlxuICAgKi9cbiAgcHVibGljIGFzeW5jIGxpc3RQdXNoRnJvbnQoXG4gICAgY2FjaGVOYW1lOiBzdHJpbmcsXG4gICAgbGlzdE5hbWU6IHN0cmluZyxcbiAgICB2YWx1ZTogc3RyaW5nIHwgVWludDhBcnJheSxcbiAgICBvcHRpb25zPzogTGlzdFB1c2hGcm9udE9wdGlvbnNcbiAgKTogUHJvbWlzZTxDYWNoZUxpc3RQdXNoRnJvbnQuUmVzcG9uc2U+IHtcbiAgICBjb25zdCBjbGllbnQgPSB0aGlzLmdldE5leHREYXRhQ2xpZW50KCk7XG4gICAgcmV0dXJuIGF3YWl0IGNsaWVudC5saXN0UHVzaEZyb250KFxuICAgICAgY2FjaGVOYW1lLFxuICAgICAgbGlzdE5hbWUsXG4gICAgICB2YWx1ZSxcbiAgICAgIG9wdGlvbnM/LnRydW5jYXRlQmFja1RvU2l6ZSxcbiAgICAgIG9wdGlvbnM/LnR0bFxuICAgICk7XG4gIH1cblxuICAvKipcbiAgICogUmVtb3ZlcyBhbGwgZWxlbWVudHMgZnJvbSB0aGUgZ2l2ZW4gbGlzdCBlcXVhbCB0byB0aGUgZ2l2ZW4gdmFsdWUuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBjYWNoZU5hbWUgLSBUaGUgY2FjaGUgY29udGFpbmluZyB0aGUgbGlzdC5cbiAgICogQHBhcmFtIHtzdHJpbmd9IGxpc3ROYW1lIC0gVGhlIGxpc3QgdG8gcmVtb3ZlIGZyb20uXG4gICAqIEBwYXJhbSB7c3RyaW5nIHwgVWludDhBcnJheX0gdmFsdWUgLSBUaGUgdmFsdWUgdG8gcmVtb3ZlLlxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxDYWNoZUxpc3RSZW1vdmVWYWx1ZS5SZXNwb25zZT59IC1cbiAgICoge0BsaW5rIENhY2hlTGlzdFJlbW92ZVZhbHVlLlN1Y2Nlc3N9IG9uIHN1Y2Nlc3MuIFJlbW92aW5nIGFuIGVsZW1lbnQgdGhhdFxuICAgKiBkb2VzIG5vdCBvY2N1ciBpbiB0aGUgbGlzdCBvciByZW1vdmluZyBmcm9tIGEgbm9uLWV4aXN0ZW50IGxpc3QgY291bnRzIGFzIGFcbiAgICogc3VjY2Vzcy5cbiAgICoge0BsaW5rIENhY2hlTGlzdFJlbW92ZVZhbHVlLkVycm9yfSBvbiBmYWlsdXJlLlxuICAgKi9cbiAgcHVibGljIGFzeW5jIGxpc3RSZW1vdmVWYWx1ZShcbiAgICBjYWNoZU5hbWU6IHN0cmluZyxcbiAgICBsaXN0TmFtZTogc3RyaW5nLFxuICAgIHZhbHVlOiBzdHJpbmcgfCBVaW50OEFycmF5XG4gICk6IFByb21pc2U8Q2FjaGVMaXN0UmVtb3ZlVmFsdWUuUmVzcG9uc2U+IHtcbiAgICBjb25zdCBjbGllbnQgPSB0aGlzLmdldE5leHREYXRhQ2xpZW50KCk7XG4gICAgcmV0dXJuIGF3YWl0IGNsaWVudC5saXN0UmVtb3ZlVmFsdWUoY2FjaGVOYW1lLCBsaXN0TmFtZSwgdmFsdWUpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldGFpbnMgc2xpY2Ugb2YgZWxlbWVudHMgb2YgYSBnaXZlbiBsaXN0LCBkZWxldGVzIHRoZSByZXN0IG9mIHRoZSBsaXN0XG4gICAqIHRoYXQgaXNuJ3QgYmVpbmcgcmV0YWluZWQuIFJldHVybnMgYSBTdWNjZXNzIG9yIEVycm9yLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gY2FjaGVOYW1lIC0gVGhlIGNhY2hlIGNvbnRhaW5pbmcgdGhlIGxpc3QuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBsaXN0TmFtZSAtIFRoZSBsaXN0IHRvIHJldGFpbiBhIHNsaWNlIG9mLlxuICAgKiBAcGFyYW0ge0xpc3RSZXRhaW5DYWxsT3B0aW9uc30gW29wdGlvbnNdXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0aW9ucy5zdGFydEluZGV4XSAtIFN0YXJ0IGluY2x1c2l2ZSBpbmRleCBmb3IgZmV0Y2hcbiAgICogb3BlcmF0aW9uLiBEZWZhdWx0cyB0byBzdGFydCBvZiBhcnJheSBpZiBub3QgZ2l2ZW4sIDAuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0aW9ucy5lbmRJbmRleF0gLSBFbmQgZXhjbHVzaXZlIGluZGV4IGZvciBmZXRjaFxuICAgKiBvcGVyYXRpb24uIERlZmF1bHRzIHRvIGVuZCBvZiBhcnJheSBpZiBub3QgZ2l2ZW4uXG4gICAqIEBwYXJhbSB7Q29sbGVjdGlvblR0bH0gW29wdGlvbnMudHRsXSAtIEhvdyB0aGUgVFRMIHNob3VsZCBiZSBtYW5hZ2VkLlxuICAgKiBSZWZyZXNoZXMgdGhlIGxpc3QncyBUVEwgdXNpbmcgdGhlIGNsaWVudCdzIGRlZmF1bHQgaWYgdGhpcyBpcyBub3RcbiAgICogc3VwcGxpZWQuXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPENhY2hlTGlzdFJldGFpbi5SZXNwb25zZT59IC1cbiAgICoge0BsaW5rIENhY2hlTGlzdFJldGFpbi5TdWNjZXNzfSBvbiBzdWNjZXNzLlxuICAgKiB7QGxpbmsgQ2FjaGVMaXN0UmV0YWluLkVycm9yfSBvbiBmYWlsdXJlLlxuICAgKi9cbiAgcHVibGljIGFzeW5jIGxpc3RSZXRhaW4oXG4gICAgY2FjaGVOYW1lOiBzdHJpbmcsXG4gICAgbGlzdE5hbWU6IHN0cmluZyxcbiAgICBvcHRpb25zPzogTGlzdFJldGFpbkNhbGxPcHRpb25zXG4gICk6IFByb21pc2U8Q2FjaGVMaXN0UmV0YWluLlJlc3BvbnNlPiB7XG4gICAgY29uc3QgY2xpZW50ID0gdGhpcy5nZXROZXh0RGF0YUNsaWVudCgpO1xuICAgIHJldHVybiBhd2FpdCBjbGllbnQubGlzdFJldGFpbihcbiAgICAgIGNhY2hlTmFtZSxcbiAgICAgIGxpc3ROYW1lLFxuICAgICAgb3B0aW9ucz8uc3RhcnRJbmRleCxcbiAgICAgIG9wdGlvbnM/LmVuZEluZGV4LFxuICAgICAgb3B0aW9ucz8udHRsXG4gICAgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBGZXRjaGVzIGFsbCBlbGVtZW50cyBvZiB0aGUgZ2l2ZW4gc2V0XG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBjYWNoZU5hbWUgLSBUaGUgY2FjaGUgY29udGFpbmluZyB0aGUgc2V0LlxuICAgKiBAcGFyYW0ge3N0cmluZ30gc2V0TmFtZSAtIFRoZSBzZXQgdG8gZmV0Y2guXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPENhY2hlU2V0RmV0Y2guUmVzcG9uc2U+fSAtXG4gICAqIHtAbGluayBDYWNoZVNldEZldGNoLkhpdH0gY29udGFpbmluZyB0aGUgc2V0IGVsZW1lbnRzIGlmIHRoZSBzZXQgZXhpc3RzLlxuICAgKiB7QGxpbmsgQ2FjaGVTZXRGZXRjaC5NaXNzfSBpZiB0aGUgc2V0IGRvZXMgbm90IGV4aXN0LlxuICAgKiB7QGxpbmsgQ2FjaGVTZXRGZXRjaC5FcnJvcn0gb24gZmFpbHVyZS5cbiAgICovXG4gIHB1YmxpYyBhc3luYyBzZXRGZXRjaChcbiAgICBjYWNoZU5hbWU6IHN0cmluZyxcbiAgICBzZXROYW1lOiBzdHJpbmdcbiAgKTogUHJvbWlzZTxDYWNoZVNldEZldGNoLlJlc3BvbnNlPiB7XG4gICAgY29uc3QgY2xpZW50ID0gdGhpcy5nZXROZXh0RGF0YUNsaWVudCgpO1xuICAgIHJldHVybiBhd2FpdCBjbGllbnQuc2V0RmV0Y2goY2FjaGVOYW1lLCBzZXROYW1lKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBZGRzIGFuIGVsZW1lbnQgdG8gdGhlIGdpdmVuIHNldC4gQ3JlYXRlcyB0aGUgc2V0IGlmIGl0IGRvZXMgbm90IGFscmVhZHlcbiAgICogZXhpc3QuXG4gICAqXG4gICAqIEByZW1hcmtzXG4gICAqIEFmdGVyIHRoaXMgb3BlcmF0aW9uIHRoZSBzZXQgd2lsbCBjb250YWluIHRoZSB1bmlvbiBvZiB0aGUgZWxlbWVudCBwYXNzZWRcbiAgICogaW4gYW5kIHRoZSBvcmlnaW5hbCBlbGVtZW50cyBvZiB0aGUgc2V0LlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gY2FjaGVOYW1lIC0gVGhlIGNhY2hlIHRvIHN0b3JlIHRoZSBzZXQgaW4uXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBzZXROYW1lIC0gVGhlIHNldCB0byBhZGQgdG8uXG4gICAqIEBwYXJhbSB7c3RyaW5nIHwgVWludDhBcnJheX0gZWxlbWVudCAtIFRoZSBlbGVtZW50IHRvIGFkZC5cbiAgICogQHBhcmFtIHtTZXRBZGRFbGVtZW50T3B0aW9uc30gb3B0aW9uc1xuICAgKiBAcGFyYW0ge0NvbGxlY3Rpb25UdGx9IFtvcHRpb25zLnR0bF0gLSBIb3cgdGhlIFRUTCBzaG91bGQgYmUgbWFuYWdlZC5cbiAgICogUmVmcmVzaGVzIHRoZSBzZXQncyBUVEwgdXNpbmcgdGhlIGNsaWVudCdzIGRlZmF1bHQgaWYgdGhpcyBpcyBub3Qgc3VwcGxpZWQuXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPENhY2hlU2V0QWRkRWxlbWVudC5SZXNwb25zZT59IC1cbiAgICoge0BsaW5rIENhY2hlU2V0QWRkRWxlbWVudC5TdWNjZXNzfSBvbiBzdWNjZXNzLlxuICAgKiB7QGxpbmsgQ2FjaGVTZXRBZGRFbGVtZW50LkVycm9yfSBvbiBmYWlsdXJlLlxuICAgKi9cbiAgcHVibGljIGFzeW5jIHNldEFkZEVsZW1lbnQoXG4gICAgY2FjaGVOYW1lOiBzdHJpbmcsXG4gICAgc2V0TmFtZTogc3RyaW5nLFxuICAgIGVsZW1lbnQ6IHN0cmluZyB8IFVpbnQ4QXJyYXksXG4gICAgb3B0aW9ucz86IFNldEFkZEVsZW1lbnRPcHRpb25zXG4gICk6IFByb21pc2U8Q2FjaGVTZXRBZGRFbGVtZW50LlJlc3BvbnNlPiB7XG4gICAgcmV0dXJuIChcbiAgICAgIGF3YWl0IHRoaXMuc2V0QWRkRWxlbWVudHMoXG4gICAgICAgIGNhY2hlTmFtZSxcbiAgICAgICAgc2V0TmFtZSxcbiAgICAgICAgW2VsZW1lbnRdIGFzIHN0cmluZ1tdIHwgVWludDhBcnJheVtdLFxuICAgICAgICBvcHRpb25zXG4gICAgICApXG4gICAgKS50b1Npbmd1bGFyUmVzcG9uc2UoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBZGRzIG11bHRpcGxlIGVsZW1lbnRzIHRvIHRoZSBnaXZlbiBzZXQuIENyZWF0ZXMgdGhlIHNldCBpZiBpdCBkb2VzIG5vdFxuICAgKiBhbHJlYWR5IGV4aXN0LlxuICAgKlxuICAgKiBAcmVtYXJrc1xuICAgKiBBZnRlciB0aGlzIG9wZXJhdGlvbiwgdGhlIHNldCB3aWxsIGNvbnRhaW4gdGhlIHVuaW9uIG9mIHRoZSBlbGVtZW50cyBwYXNzZWRcbiAgICogaW4gYW5kIHRoZSBvcmlnaW5hbCBlbGVtZW50cyBvZiB0aGUgc2V0LlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gY2FjaGVOYW1lIC0gVGhlIGNhY2hlIHRvIHN0b3JlIHRoZSBzZXQgaW4uXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBzZXROYW1lIC0gVGhlIHNldCB0byBhZGQgdG8uXG4gICAqIEBwYXJhbSB7c3RyaW5nW10gfCBVaW50OEFycmF5W119IGVsZW1lbnRzIC0gVGhlIGVsZW1lbnRzIHRvIGFkZC5cbiAgICogQHBhcmFtIHtTZXRBZGRFbGVtZW50c09wdGlvbnN9IG9wdGlvbnNcbiAgICogQHBhcmFtIHtDb2xsZWN0aW9uVHRsfSBbb3B0aW9ucy50dGxdIC0gSG93IHRoZSBUVEwgc2hvdWxkIGJlIG1hbmFnZWQuXG4gICAqIFJlZnJlc2hlcyB0aGUgc2V0J3MgVFRMIHVzaW5nIHRoZSBjbGllbnQncyBkZWZhdWx0IGlmIHRoaXMgaXMgbm90IHN1cHBsaWVkLlxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxDYWNoZVNldEFkZEVsZW1lbnRzLlJlc3BvbnNlPn0gLVxuICAgKiB7QGxpbmsgQ2FjaGVTZXRBZGRFbGVtZW50cy5TdWNjZXNzfSBvbiBzdWNjZXNzLlxuICAgKiB7QGxpbmsgQ2FjaGVTZXRBZGRFbGVtZW50cy5FcnJvcn0gb24gZmFpbHVyZS5cbiAgICovXG4gIHB1YmxpYyBhc3luYyBzZXRBZGRFbGVtZW50cyhcbiAgICBjYWNoZU5hbWU6IHN0cmluZyxcbiAgICBzZXROYW1lOiBzdHJpbmcsXG4gICAgZWxlbWVudHM6IHN0cmluZ1tdIHwgVWludDhBcnJheVtdLFxuICAgIG9wdGlvbnM/OiBTZXRBZGRFbGVtZW50c09wdGlvbnNcbiAgKTogUHJvbWlzZTxDYWNoZVNldEFkZEVsZW1lbnRzLlJlc3BvbnNlPiB7XG4gICAgY29uc3QgY2xpZW50ID0gdGhpcy5nZXROZXh0RGF0YUNsaWVudCgpO1xuICAgIHJldHVybiBhd2FpdCBjbGllbnQuc2V0QWRkRWxlbWVudHMoXG4gICAgICBjYWNoZU5hbWUsXG4gICAgICBzZXROYW1lLFxuICAgICAgZWxlbWVudHMsXG4gICAgICBvcHRpb25zPy50dGxcbiAgICApO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlbW92ZXMgYW4gZWxlbWVudCBmcm9tIHRoZSBnaXZlbiBzZXQuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBjYWNoZU5hbWUgLSBUaGUgY2FjaGUgY29udGFpbmluZyB0aGUgc2V0LlxuICAgKiBAcGFyYW0ge3N0cmluZ30gc2V0TmFtZSAtIFRoZSBzZXQgdG8gcmVtb3ZlIGZyb20uXG4gICAqIEBwYXJhbSB7c3RyaW5nIHwgVWludDhBcnJheX0gZWxlbWVudCAtIFRoZSBlbGVtZW50IHRvIHJlbW92ZS5cbiAgICogQHJldHVybnMge1Byb21pc2U8Q2FjaGVTZXRSZW1vdmVFbGVtZW50LlJlc3BvbnNlPn0gLVxuICAgKiB7QGxpbmsgQ2FjaGVTZXRSZW1vdmVFbGVtZW50LlN1Y2Nlc3N9IG9uIHN1Y2Nlc3MuIFJlbW92aW5nIGFuIGVsZW1lbnQgdGhhdFxuICAgKiBkb2VzIG5vdCBvY2N1ciBpbiB0aGUgc2V0IG9yIHJlbW92aW5nIGZyb20gYSBub24tZXhpc3RlbnQgc2V0IGNvdW50cyBhcyBhXG4gICAqIHN1Y2Nlc3MuXG4gICAqIHtAbGluayBDYWNoZVNldFJlbW92ZUVsZW1lbnQuRXJyb3J9IG9uIGZhaWx1cmUuXG4gICAqL1xuICBwdWJsaWMgYXN5bmMgc2V0UmVtb3ZlRWxlbWVudChcbiAgICBjYWNoZU5hbWU6IHN0cmluZyxcbiAgICBzZXROYW1lOiBzdHJpbmcsXG4gICAgZWxlbWVudDogc3RyaW5nIHwgVWludDhBcnJheVxuICApOiBQcm9taXNlPENhY2hlU2V0UmVtb3ZlRWxlbWVudC5SZXNwb25zZT4ge1xuICAgIHJldHVybiAoXG4gICAgICBhd2FpdCB0aGlzLnNldFJlbW92ZUVsZW1lbnRzKGNhY2hlTmFtZSwgc2V0TmFtZSwgW2VsZW1lbnRdIGFzXG4gICAgICAgIHwgc3RyaW5nW11cbiAgICAgICAgfCBVaW50OEFycmF5W10pXG4gICAgKS50b1Npbmd1bGFyUmVzcG9uc2UoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZW1vdmVzIG11bHRpcGxlIGVsZW1lbnRzIGZyb20gdGhlIGdpdmVuIHNldC5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IGNhY2hlTmFtZSAtIFRoZSBjYWNoZSBjb250YWluaW5nIHRoZSBzZXQuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBzZXROYW1lIC0gVGhlIHNldCB0byByZW1vdmUgZnJvbS5cbiAgICogQHBhcmFtIHtzdHJpbmdbXSB8IFVpbnQ4QXJyYXlbXX0gZWxlbWVudHMgLSBUaGUgZWxlbWVudHMgdG8gcmVtb3ZlLlxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxDYWNoZVNldFJlbW92ZUVsZW1lbnRzLlJlc3BvbnNlPn0gLVxuICAgKiB7QGxpbmsgQ2FjaGVTZXRSZW1vdmVFbGVtZW50cy5TdWNjZXNzfSBvbiBzdWNjZXNzLiBSZW1vdmluZyBlbGVtZW50cyB0aGF0XG4gICAqIGRvIG5vdCBvY2N1ciBpbiB0aGUgc2V0IG9yIHJlbW92aW5nIGZyb20gYSBub24tZXhpc3RlbnQgc2V0IGNvdW50cyBhcyBhXG4gICAqIHN1Y2Nlc3MuXG4gICAqIHtAbGluayBDYWNoZVNldFJlbW92ZUVsZW1lbnRzLkVycm9yfSBvbiBmYWlsdXJlLlxuICAgKi9cbiAgcHVibGljIGFzeW5jIHNldFJlbW92ZUVsZW1lbnRzKFxuICAgIGNhY2hlTmFtZTogc3RyaW5nLFxuICAgIHNldE5hbWU6IHN0cmluZyxcbiAgICBlbGVtZW50czogc3RyaW5nW10gfCBVaW50OEFycmF5W11cbiAgKTogUHJvbWlzZTxDYWNoZVNldFJlbW92ZUVsZW1lbnRzLlJlc3BvbnNlPiB7XG4gICAgY29uc3QgY2xpZW50ID0gdGhpcy5nZXROZXh0RGF0YUNsaWVudCgpO1xuICAgIHJldHVybiBhd2FpdCBjbGllbnQuc2V0UmVtb3ZlRWxlbWVudHMoY2FjaGVOYW1lLCBzZXROYW1lLCBlbGVtZW50cyk7XG4gIH1cblxuICAvKipcbiAgICogQXNzb2NpYXRlcyB0aGUgZ2l2ZW4ga2V5IHdpdGggdGhlIGdpdmVuIHZhbHVlLiBJZiBhIHZhbHVlIGZvciB0aGUga2V5IGlzXG4gICAqIGFscmVhZHkgcHJlc2VudCBpdCBpcyBub3QgcmVwbGFjZWQgd2l0aCB0aGUgbmV3IHZhbHVlLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gY2FjaGVOYW1lIC0gVGhlIGNhY2hlIHRvIHN0b3JlIHRoZSB2YWx1ZSBpbi5cbiAgICogQHBhcmFtIHtzdHJpbmcgfCBVaW50OEFycmF5fSBrZXkgLSBUaGUga2V5IHRvIHNldC5cbiAgICogQHBhcmFtIHtzdHJpbmcgfCBVaW50OEFycmF5fSBmaWVsZCAtIFRoZSB2YWx1ZSB0byBiZSBzdG9yZWQuXG4gICAqIEBwYXJhbSB7U2V0SWZOb3RFeGlzdHNPcHRpb25zfSBbb3B0aW9uc11cbiAgICogQHBhcmFtIHtudW1iZXJ9IFtvcHRpb25zLnR0bF0gLSBUaGUgdGltZSB0byBsaXZlIGZvciB0aGUgaXRlbSBpbiB0aGUgY2FjaGUuXG4gICAqIFVzZXMgdGhlIGNsaWVudCdzIGRlZmF1bHQgVFRMIGlmIHRoaXMgaXMgbm90IHN1cHBsaWVkLlxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxDYWNoZVNldElmTm90RXhpc3RzLlJlc3BvbnNlPn0gLVxuICAgKiB7QGxpbmsgQ2FjaGVTZXRJZk5vdEV4aXN0cy5TdG9yZWR9IG9uIHN0b3JpbmcgdGhlIG5ldyB2YWx1ZS5cbiAgICoge0BsaW5rIENhY2hlU2V0SWZOb3RFeGlzdHMuTm90U3RvcmVkfSBvbiBub3Qgc3RvcmluZyB0aGUgbmV3IHZhbHVlLlxuICAgKiB7QGxpbmsgQ2FjaGVTZXRJZk5vdEV4aXN0cy5FcnJvcn0gb24gZmFpbHVyZS5cbiAgICovXG4gIHB1YmxpYyBhc3luYyBzZXRJZk5vdEV4aXN0cyhcbiAgICBjYWNoZU5hbWU6IHN0cmluZyxcbiAgICBrZXk6IHN0cmluZyB8IFVpbnQ4QXJyYXksXG4gICAgZmllbGQ6IHN0cmluZyB8IFVpbnQ4QXJyYXksXG4gICAgb3B0aW9ucz86IFNldElmTm90RXhpc3RzT3B0aW9uc1xuICApOiBQcm9taXNlPENhY2hlU2V0SWZOb3RFeGlzdHMuUmVzcG9uc2U+IHtcbiAgICBjb25zdCBjbGllbnQgPSB0aGlzLmdldE5leHREYXRhQ2xpZW50KCk7XG4gICAgcmV0dXJuIGF3YWl0IGNsaWVudC5zZXRJZk5vdEV4aXN0cyhjYWNoZU5hbWUsIGtleSwgZmllbGQsIG9wdGlvbnM/LnR0bCk7XG4gIH1cblxuICAvKipcbiAgICogRmx1c2hlcyAvIGNsZWFycyBhbGwgdGhlIGl0ZW1zIG9mIHRoZSBnaXZlbiBjYWNoZVxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gY2FjaGVOYW1lIC0gVGhlIGNhY2hlIHRvIGJlIGZsdXNoZWQuXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPENhY2hlRmx1c2guUmVzcG9uc2U+fSAtXG4gICAqIHtAbGluayBDYWNoZUZsdXNoLlN1Y2Nlc3N9IG9uIHN1Y2Nlc3MuXG4gICAqIHtAbGluayBDYWNoZUZsdXNoLkVycm9yfSBvbiBmYWlsdXJlLlxuICAgKi9cbiAgcHVibGljIGFzeW5jIGZsdXNoQ2FjaGUoY2FjaGVOYW1lOiBzdHJpbmcpOiBQcm9taXNlPENhY2hlRmx1c2guUmVzcG9uc2U+IHtcbiAgICByZXR1cm4gYXdhaXQgdGhpcy5jb250cm9sQ2xpZW50LmZsdXNoQ2FjaGUoY2FjaGVOYW1lKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBGZXRjaGVzIGFsbCBlbGVtZW50cyBvZiB0aGUgZ2l2ZW4gZGljdGlvbmFyeS5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IGNhY2hlTmFtZSAtIFRoZSBjYWNoZSB0byBwZXJmb3JtIHRoZSBsb29rdXAgaW4uXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBkaWN0aW9uYXJ5TmFtZSAtIFRoZSBkaWN0aW9uYXJ5IHRvIGZldGNoLlxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxDYWNoZURpY3Rpb25hcnlGZXRjaC5SZXNwb25zZT59IC1cbiAgICoge0BsaW5rIENhY2hlRGljdGlvbmFyeUZldGNoLkhpdH0gY29udGFpbmluZyB0aGUgZGljdGlvbmFyeSBlbGVtZW50cyBpZiB0aGVcbiAgICogZGljdGlvbmFyeSBleGlzdHMuXG4gICAqIHtAbGluayBDYWNoZURpY3Rpb25hcnlGZXRjaC5NaXNzfSBpZiB0aGUgZGljdGlvbmFyeSBkb2VzIG5vdCBleGlzdC5cbiAgICoge0BsaW5rIENhY2hlRGljdGlvbmFyeUZldGNoLkVycm9yfSBvbiBmYWlsdXJlLlxuICAgKi9cbiAgcHVibGljIGFzeW5jIGRpY3Rpb25hcnlGZXRjaChcbiAgICBjYWNoZU5hbWU6IHN0cmluZyxcbiAgICBkaWN0aW9uYXJ5TmFtZTogc3RyaW5nXG4gICk6IFByb21pc2U8Q2FjaGVEaWN0aW9uYXJ5RmV0Y2guUmVzcG9uc2U+IHtcbiAgICBjb25zdCBjbGllbnQgPSB0aGlzLmdldE5leHREYXRhQ2xpZW50KCk7XG4gICAgcmV0dXJuIGF3YWl0IGNsaWVudC5kaWN0aW9uYXJ5RmV0Y2goY2FjaGVOYW1lLCBkaWN0aW9uYXJ5TmFtZSk7XG4gIH1cblxuICAvKipcbiAgICogQWRkcyBhbiBpbnRlZ2VyIHF1YW50aXR5IHRvIGEgZmllbGQgdmFsdWUuXG4gICAqXG4gICAqIEByZW1hcmtzXG4gICAqIEluY3JlbWVudGluZyB0aGUgdmFsdWUgb2YgYSBtaXNzaW5nIGZpZWxkIHNldHMgdGhlIHZhbHVlIHRvIGFtb3VudC5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IGNhY2hlTmFtZSAtIFRoZSBjYWNoZSBjb250YWluaW5nIHRoZSBmaWVsZC5cbiAgICogQHBhcmFtIHtzdHJpbmcgfCBVaW50OEFycmF5fSBmaWVsZCAtIFRoZSBmaWVsZCB0byBpbmNyZW1lbnQuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBhbW91bnQgLSBUaGUgcXVhbnRpdHkgdG8gYWRkIHRvIHRoZSB2YWx1ZS4gTWF5IGJlIHBvc2l0aXZlLFxuICAgKiBuZWdhdGl2ZSwgb3IgemVyby4gRGVmYXVsdHMgdG8gMS5cbiAgICogQHBhcmFtIHtJbmNyZW1lbnRPcHRpb25zfSBvcHRpb25zXG4gICAqIEBwYXJhbSB7Q29sbGVjdGlvblR0bH0gW29wdGlvbnMudHRsXSAtIEhvdyB0aGUgVFRMIHNob3VsZCBiZSBtYW5hZ2VkLlxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxDYWNoZUluY3JlbWVudD59IC1cbiAgICoge0BsaW5rIENhY2hlSW5jcmVtZW50LlN1Y2Nlc3N9IGNvbnRhaW5pbmcgdGhlIGluY3JlbWVudGVkIHZhbHVlXG4gICAqIG9uIHN1Y2Nlc3MuXG4gICAqIHtAbGluayBDYWNoZUluY3JlbWVudC5FcnJvcn0gb24gZmFpbHVyZS4gSW5jcmVtZW50aW5nIGEgdmFsdWVcbiAgICogdGhhdCB3YXMgbm90IHNldCB1c2luZyB0aGlzIG1ldGhvZCBvciBpcyBub3QgdGhlIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZlxuICAgKiBhbiBpbnRlZ2VyIHJlc3VsdHMgaW4gYSBmYWlsdXJlIHdpdGggYSBGYWlsZWRQcmVjb25kaXRpb25FeGNlcHRpb24gZXJyb3IuXG4gICAqL1xuICBwdWJsaWMgYXN5bmMgaW5jcmVtZW50KFxuICAgIGNhY2hlTmFtZTogc3RyaW5nLFxuICAgIGZpZWxkOiBzdHJpbmcgfCBVaW50OEFycmF5LFxuICAgIGFtb3VudCA9IDEsXG4gICAgb3B0aW9ucz86IEluY3JlbWVudE9wdGlvbnNcbiAgKTogUHJvbWlzZTxDYWNoZUluY3JlbWVudC5SZXNwb25zZT4ge1xuICAgIGNvbnN0IGNsaWVudCA9IHRoaXMuZ2V0TmV4dERhdGFDbGllbnQoKTtcbiAgICByZXR1cm4gYXdhaXQgY2xpZW50LmluY3JlbWVudChjYWNoZU5hbWUsIGZpZWxkLCBhbW91bnQsIG9wdGlvbnM/LnR0bCk7XG4gIH1cblxuICAvKipcbiAgICogQWRkcyBhbiBlbGVtZW50IHRvIHRoZSBnaXZlbiBkaWN0aW9uYXJ5LiBDcmVhdGVzIHRoZSBkaWN0aW9uYXJ5IGlmIGl0IGRvZXNcbiAgICogbm90IGFscmVhZHkgZXhpc3QuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBjYWNoZU5hbWUgLSBUaGUgY2FjaGUgdG8gc3RvcmUgdGhlIGRpY3Rpb25hcnkgaW4uXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBkaWN0aW9uYXJ5TmFtZSAtIFRoZSBkaWN0aW9uYXJ5IHRvIGFkZCB0by5cbiAgICogQHBhcmFtIHtzdHJpbmcgfCBVaW50OEFycmF5fSBmaWVsZCAtIFRoZSBmaWVsZCB0byBzZXQuXG4gICAqIEBwYXJhbSB7c3RyaW5nIHwgVWludDhBcnJheX0gdmFsdWUgLSBUaGUgdmFsdWUgdG8gc3RvcmUuXG4gICAqIEBwYXJhbSB7RGljdGlvbmFyeVNldEZpZWxkT3B0aW9uc30gb3B0aW9uc1xuICAgKiBAcGFyYW0ge0NvbGxlY3Rpb25UdGx9IFtvcHRpb25zLnR0bF0gLSBIb3cgdGhlIFRUTCBzaG91bGQgYmUgbWFuYWdlZC5cbiAgICogUmVmcmVzaGVzIHRoZSBkaWN0aW9uYXJ5J3MgVFRMIHVzaW5nIHRoZSBjbGllbnQncyBkZWZhdWx0IGlmIHRoaXMgaXMgbm90XG4gICAqIHN1cHBsaWVkLlxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxDYWNoZURpY3Rpb25hcnlTZXRGaWVsZC5SZXNwb25zZT59IC1cbiAgICoge0BsaW5rIENhY2hlRGljdGlvbmFyeVNldEZpZWxkLlN1Y2Nlc3N9IG9uIHN1Y2Nlc3MuXG4gICAqIHtAbGluayBDYWNoZURpY3Rpb25hcnlTZXRGaWVsZC5FcnJvcn0gb24gZmFpbHVyZS5cbiAgICovXG4gIHB1YmxpYyBhc3luYyBkaWN0aW9uYXJ5U2V0RmllbGQoXG4gICAgY2FjaGVOYW1lOiBzdHJpbmcsXG4gICAgZGljdGlvbmFyeU5hbWU6IHN0cmluZyxcbiAgICBmaWVsZDogc3RyaW5nIHwgVWludDhBcnJheSxcbiAgICB2YWx1ZTogc3RyaW5nIHwgVWludDhBcnJheSxcbiAgICBvcHRpb25zPzogRGljdGlvbmFyeVNldEZpZWxkT3B0aW9uc1xuICApOiBQcm9taXNlPENhY2hlRGljdGlvbmFyeVNldEZpZWxkLlJlc3BvbnNlPiB7XG4gICAgY29uc3QgY2xpZW50ID0gdGhpcy5nZXROZXh0RGF0YUNsaWVudCgpO1xuICAgIHJldHVybiBhd2FpdCBjbGllbnQuZGljdGlvbmFyeVNldEZpZWxkKFxuICAgICAgY2FjaGVOYW1lLFxuICAgICAgZGljdGlvbmFyeU5hbWUsXG4gICAgICBmaWVsZCxcbiAgICAgIHZhbHVlLFxuICAgICAgb3B0aW9ucz8udHRsXG4gICAgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBZGRzIG11bHRpcGxlIGVsZW1lbnRzIHRvIHRoZSBnaXZlbiBkaWN0aW9uYXJ5LiBDcmVhdGVzIHRoZSBkaWN0aW9uYXJ5IGlmXG4gICAqIGl0IGRvZXMgbm90IGFscmVhZHkgZXhpc3QuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBjYWNoZU5hbWUgLSBUaGUgY2FjaGUgdG8gc3RvcmUgdGhlIGRpY3Rpb25hcnkgaW4uXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBkaWN0aW9uYXJ5TmFtZSAtIFRoZSBkaWN0aW9uYXJ5IHRvIGFkZCB0by5cbiAgICogQHBhcmFtIHtNYXA8c3RyaW5nIHwgVWludDhBcnJheSwgc3RyaW5nIHwgVWludDhBcnJheT59IGVsZW1lbnRzIC0gVGhlXG4gICAqIGVsZW1lbnRzIHRvIHNldC5cbiAgICogQHBhcmFtIHtEaWN0aW9uYXJ5U2V0RmllbGRzT3B0aW9uc30gb3B0aW9uc1xuICAgKiBAcGFyYW0ge0NvbGxlY3Rpb25UdGx9IFtvcHRpb25zLnR0bF0gLSBIb3cgdGhlIFRUTCBzaG91bGQgYmUgbWFuYWdlZC5cbiAgICogUmVmcmVzaGVzIHRoZSBkaWN0aW9uYXJ5J3MgVFRMIHVzaW5nIHRoZSBjbGllbnQncyBkZWZhdWx0IGlmIHRoaXMgaXMgbm90XG4gICAqIHN1cHBsaWVkLlxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxDYWNoZURpY3Rpb25hcnlTZXRGaWVsZHMuUmVzcG9uc2U+fSAtXG4gICAqIHtAbGluayBDYWNoZURpY3Rpb25hcnlTZXRGaWVsZHMuU3VjY2Vzc30gb24gc3VjY2Vzcy5cbiAgICoge0BsaW5rIENhY2hlRGljdGlvbmFyeVNldEZpZWxkcy5FcnJvcn0gb24gZmFpbHVyZS5cbiAgICovXG4gIHB1YmxpYyBhc3luYyBkaWN0aW9uYXJ5U2V0RmllbGRzKFxuICAgIGNhY2hlTmFtZTogc3RyaW5nLFxuICAgIGRpY3Rpb25hcnlOYW1lOiBzdHJpbmcsXG4gICAgZWxlbWVudHM6XG4gICAgICB8IE1hcDxzdHJpbmcgfCBVaW50OEFycmF5LCBzdHJpbmcgfCBVaW50OEFycmF5PlxuICAgICAgfCBSZWNvcmQ8c3RyaW5nLCBzdHJpbmcgfCBVaW50OEFycmF5PlxuICAgICAgfCBBcnJheTxbc3RyaW5nLCBzdHJpbmcgfCBVaW50OEFycmF5XT4sXG4gICAgb3B0aW9ucz86IERpY3Rpb25hcnlTZXRGaWVsZE9wdGlvbnNcbiAgKTogUHJvbWlzZTxDYWNoZURpY3Rpb25hcnlTZXRGaWVsZHMuUmVzcG9uc2U+IHtcbiAgICBjb25zdCBjbGllbnQgPSB0aGlzLmdldE5leHREYXRhQ2xpZW50KCk7XG4gICAgcmV0dXJuIGF3YWl0IGNsaWVudC5kaWN0aW9uYXJ5U2V0RmllbGRzKFxuICAgICAgY2FjaGVOYW1lLFxuICAgICAgZGljdGlvbmFyeU5hbWUsXG4gICAgICBlbGVtZW50cyxcbiAgICAgIG9wdGlvbnM/LnR0bFxuICAgICk7XG4gIH1cblxuICAvKipcbiAgICogR2V0cyB0aGUgdmFsdWUgc3RvcmVkIGZvciB0aGUgZ2l2ZW4gZGljdGlvbmFyeSBhbmQgZmllbGQuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBjYWNoZU5hbWUgLSBUaGUgY2FjaGUgY29udGFpbmluZyB0aGUgZGljdGlvbmFyeS5cbiAgICogQHBhcmFtIHtzdHJpbmd9IGRpY3Rpb25hcnlOYW1lIC0gVGhlIGRpY3Rpb25hcnkgdG8gbG9vayB1cC5cbiAgICogQHBhcmFtIHtzdHJpbmcgfCBVaW50OEFycmF5fSBmaWVsZCAtIFRoZSBmaWVsZCB0byBsb29rIHVwLlxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxDYWNoZURpY3Rpb25hcnlHZXRGaWVsZC5SZXNwb25zZT59IC1cbiAgICoge0BsaW5rIENhY2hlRGljdGlvbmFyeUdldEZpZWxkLkhpdH0gY29udGFpbmluZyB0aGUgZGljdGlvbmFyeSBlbGVtZW50IGlmXG4gICAqIG9uZSBpcyBmb3VuZC5cbiAgICoge0BsaW5rIENhY2hlRGljdGlvbmFyeUdldEZpZWxkLk1pc3N9IGlmIHRoZSBkaWN0aW9uYXJ5IGRvZXMgbm90IGV4aXN0LlxuICAgKiB7QGxpbmsgQ2FjaGVEaWN0aW9uYXJ5R2V0RmllbGQuRXJyb3J9IG9uIGZhaWx1cmUuXG4gICAqL1xuICBwdWJsaWMgYXN5bmMgZGljdGlvbmFyeUdldEZpZWxkKFxuICAgIGNhY2hlTmFtZTogc3RyaW5nLFxuICAgIGRpY3Rpb25hcnlOYW1lOiBzdHJpbmcsXG4gICAgZmllbGQ6IHN0cmluZyB8IFVpbnQ4QXJyYXlcbiAgKTogUHJvbWlzZTxDYWNoZURpY3Rpb25hcnlHZXRGaWVsZC5SZXNwb25zZT4ge1xuICAgIGNvbnN0IGNsaWVudCA9IHRoaXMuZ2V0TmV4dERhdGFDbGllbnQoKTtcbiAgICByZXR1cm4gYXdhaXQgY2xpZW50LmRpY3Rpb25hcnlHZXRGaWVsZChjYWNoZU5hbWUsIGRpY3Rpb25hcnlOYW1lLCBmaWVsZCk7XG4gIH1cblxuICAvKipcbiAgICogR2V0cyBtdWx0aXBsZSB2YWx1ZXMgZnJvbSB0aGUgZ2l2ZW4gZGljdGlvbmFyeS5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IGNhY2hlTmFtZSAtIFRoZSBjYWNoZSBjb250YWluaW5nIHRoZSBkaWN0aW9uYXJ5LlxuICAgKiBAcGFyYW0ge3N0cmluZ30gZGljdGlvbmFyeU5hbWUgLSBUaGUgZGljdGlvbmFyeSB0byBsb29rIHVwLlxuICAgKiBAcGFyYW0ge3N0cmluZ1tdIHwgVWludDhBcnJheVtdfSBmaWVsZHMgLSBUaGUgZmllbGRzIHRvIGxvb2sgdXAuXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPENhY2hlRGljdGlvbmFyeUdldEZpZWxkcy5SZXNwb25zZT59IC1cbiAgICoge0BsaW5rIENhY2hlRGljdGlvbmFyeUdldEZpZWxkcy5IaXR9IGNvbnRhaW5pbmcgdGhlIGRpY3Rpb25hcnkgZWxlbWVudHMgaWZcbiAgICogdGhlIGRpY3Rpb25hcnkgZXhpc3RzLlxuICAgKiB7QGxpbmsgQ2FjaGVEaWN0aW9uYXJ5R2V0RmllbGRzLk1pc3N9IGlmIHRoZSBkaWN0aW9uYXJ5IGRvZXMgbm90IGV4aXN0LlxuICAgKiB7QGxpbmsgQ2FjaGVEaWN0aW9uYXJ5R2V0RmllbGRzLkVycm9yfSBvbiBmYWlsdXJlLlxuICAgKi9cbiAgcHVibGljIGFzeW5jIGRpY3Rpb25hcnlHZXRGaWVsZHMoXG4gICAgY2FjaGVOYW1lOiBzdHJpbmcsXG4gICAgZGljdGlvbmFyeU5hbWU6IHN0cmluZyxcbiAgICBmaWVsZHM6IHN0cmluZ1tdIHwgVWludDhBcnJheVtdXG4gICk6IFByb21pc2U8Q2FjaGVEaWN0aW9uYXJ5R2V0RmllbGRzLlJlc3BvbnNlPiB7XG4gICAgY29uc3QgY2xpZW50ID0gdGhpcy5nZXROZXh0RGF0YUNsaWVudCgpO1xuICAgIHJldHVybiBhd2FpdCBjbGllbnQuZGljdGlvbmFyeUdldEZpZWxkcyhjYWNoZU5hbWUsIGRpY3Rpb25hcnlOYW1lLCBmaWVsZHMpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlbW92ZXMgYW4gZWxlbWVudCBmcm9tIHRoZSBnaXZlbiBkaWN0aW9uYXJ5LlxuICAgKlxuICAgKiBAcmVtYXJrc1xuICAgKiBQZXJmb3JtcyBhIG5vLW9wIGlmIHRoZSBkaWN0aW9uYXJ5IG9yIGZpZWxkIGRvZXMgbm90IGV4aXN0LlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gY2FjaGVOYW1lIC0gVGhlIGNhY2hlIGNvbnRhaW5pbmcgdGhlIGRpY3Rpb25hcnkuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBkaWN0aW9uYXJ5TmFtZSAtIFRoZSBkaWN0aW9uYXJ5IHRvIHJlbW92ZSBmcm9tLlxuICAgKiBAcGFyYW0ge3N0cmluZyB8IFVpbnQ4QXJyYXl9IGZpZWxkIC0gVGhlIGZpZWxkIHRvIHJlbW92ZS5cbiAgICogQHJldHVybnMge1Byb21pc2U8Q2FjaGVEaWN0aW9uYXJ5UmVtb3ZlRmllbGQuUmVzcG9uc2U+fSAtXG4gICAqIHtAbGluayBDYWNoZURpY3Rpb25hcnlSZW1vdmVGaWVsZC5TdWNjZXNzfSBvbiBzdWNjZXNzLlxuICAgKiB7QGxpbmsgQ2FjaGVEaWN0aW9uYXJ5UmVtb3ZlRmllbGQuRXJyb3J9IG9uIGZhaWx1cmUuXG4gICAqL1xuICBwdWJsaWMgYXN5bmMgZGljdGlvbmFyeVJlbW92ZUZpZWxkKFxuICAgIGNhY2hlTmFtZTogc3RyaW5nLFxuICAgIGRpY3Rpb25hcnlOYW1lOiBzdHJpbmcsXG4gICAgZmllbGQ6IHN0cmluZyB8IFVpbnQ4QXJyYXlcbiAgKTogUHJvbWlzZTxDYWNoZURpY3Rpb25hcnlSZW1vdmVGaWVsZC5SZXNwb25zZT4ge1xuICAgIGNvbnN0IGNsaWVudCA9IHRoaXMuZ2V0TmV4dERhdGFDbGllbnQoKTtcbiAgICByZXR1cm4gYXdhaXQgY2xpZW50LmRpY3Rpb25hcnlSZW1vdmVGaWVsZChjYWNoZU5hbWUsIGRpY3Rpb25hcnlOYW1lLCBmaWVsZCk7XG4gIH1cblxuICAvKipcbiAgICogUmVtb3ZlcyBtdWx0aXBsZSBmaWVsZHMgZnJvbSB0aGUgZ2l2ZW4gZGljdGlvbmFyeS5cbiAgICpcbiAgICogQHJlbWFya3NcbiAgICogUGVyZm9ybXMgYSBuby1vcCBpZiB0aGUgZGljdGlvbmFyeSBvciBmaWVsZHMgZG8gbm90IGV4aXN0LlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gY2FjaGVOYW1lIC0gVGhlIGNhY2hlIGNvbnRhaW5pbmcgdGhlIGRpY3Rpb25hcnkuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBkaWN0aW9uYXJ5TmFtZSAtIFRoZSBkaWN0aW9uYXJ5IHRvIHJlbW92ZSBmcm9tLlxuICAgKiBAcGFyYW0ge3N0cmluZ1tdIHwgVWludDhBcnJheVtdfSBmaWVsZHMgLSBUaGUgZmllbGRzIHRvIHJlbW92ZS5cbiAgICogQHJldHVybnMge1Byb21pc2U8Q2FjaGVEaWN0aW9uYXJ5UmVtb3ZlRmllbGRzLlJlc3BvbnNlPn0gLVxuICAgKiB7QGxpbmsgQ2FjaGVEaWN0aW9uYXJ5UmVtb3ZlRmllbGRzLlN1Y2Nlc3N9IG9uIHN1Y2Nlc3MuXG4gICAqIHtAbGluayBDYWNoZURpY3Rpb25hcnlSZW1vdmVGaWVsZHMuRXJyb3J9IG9uIGZhaWx1cmUuXG4gICAqL1xuICBwdWJsaWMgYXN5bmMgZGljdGlvbmFyeVJlbW92ZUZpZWxkcyhcbiAgICBjYWNoZU5hbWU6IHN0cmluZyxcbiAgICBkaWN0aW9uYXJ5TmFtZTogc3RyaW5nLFxuICAgIGZpZWxkczogc3RyaW5nW10gfCBVaW50OEFycmF5W11cbiAgKTogUHJvbWlzZTxDYWNoZURpY3Rpb25hcnlSZW1vdmVGaWVsZHMuUmVzcG9uc2U+IHtcbiAgICBjb25zdCBjbGllbnQgPSB0aGlzLmdldE5leHREYXRhQ2xpZW50KCk7XG4gICAgcmV0dXJuIGF3YWl0IGNsaWVudC5kaWN0aW9uYXJ5UmVtb3ZlRmllbGRzKFxuICAgICAgY2FjaGVOYW1lLFxuICAgICAgZGljdGlvbmFyeU5hbWUsXG4gICAgICBmaWVsZHNcbiAgICApO1xuICB9XG5cbiAgLyoqXG4gICAqIEFkZHMgYW4gaW50ZWdlciBxdWFudGl0eSB0byBhIGRpY3Rpb25hcnkgdmFsdWUuXG4gICAqXG4gICAqIEByZW1hcmtzXG4gICAqIEluY3JlbWVudGluZyB0aGUgdmFsdWUgb2YgYSBtaXNzaW5nIGZpZWxkIHNldHMgdGhlIHZhbHVlIHRvIGFtb3VudC5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IGNhY2hlTmFtZSAtIFRoZSBjYWNoZSBjb250YWluaW5nIHRoZSBkaWN0aW9uYXJ5LlxuICAgKiBAcGFyYW0ge3N0cmluZ30gZGljdGlvbmFyeU5hbWUgLSBUaGUgZGljdGlvbmFyeSB0byBzZXQuXG4gICAqIEBwYXJhbSB7c3RyaW5nIHwgVWludDhBcnJheX0gZmllbGQgLSBUaGUgZmllbGQgdG8gaW5jcmVtZW50LlxuICAgKiBAcGFyYW0ge251bWJlcn0gYW1vdW50IC0gVGhlIHF1YW50aXR5IHRvIGFkZCB0byB0aGUgdmFsdWUuIE1heSBiZSBwb3NpdGl2ZSxcbiAgICogbmVnYXRpdmUsIG9yIHplcm8uIERlZmF1bHRzIHRvIDEuXG4gICAqIEBwYXJhbSB7RGljdGlvbmFyeUluY3JlbWVudE9wdGlvbnN9IG9wdGlvbnNcbiAgICogQHBhcmFtIHtDb2xsZWN0aW9uVHRsfSBbb3B0aW9ucy50dGxdIC0gSG93IHRoZSBUVEwgc2hvdWxkIGJlIG1hbmFnZWQuXG4gICAqIFJlZnJlc2hlcyB0aGUgZGljdGlvbmFyeSdzIFRUTCB1c2luZyB0aGUgY2xpZW50J3MgZGVmYXVsdCBpZiB0aGlzIGlzIG5vdFxuICAgKiBzdXBwbGllZC5cbiAgICogQHJldHVybnMge1Byb21pc2U8Q2FjaGVEaWN0aW9uYXJ5SW5jcmVtZW50LlJlc3BvbnNlPn0gLVxuICAgKiB7QGxpbmsgQ2FjaGVEaWN0aW9uYXJ5SW5jcmVtZW50LlN1Y2Nlc3N9IGNvbnRhaW5pbmcgdGhlIGluY3JlbWVudGVkIHZhbHVlXG4gICAqIG9uIHN1Y2Nlc3MuXG4gICAqIHtAbGluayBDYWNoZURpY3Rpb25hcnlJbmNyZW1lbnQuRXJyb3J9IG9uIGZhaWx1cmUuIEluY3JlbWVudGluZyBhIHZhbHVlXG4gICAqIHRoYXQgd2FzIG5vdCBzZXQgdXNpbmcgdGhpcyBtZXRob2Qgb3IgaXMgbm90IHRoZSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2ZcbiAgICogYW4gaW50ZWdlciByZXN1bHRzIGluIGEgZmFpbHVyZSB3aXRoIGEgRmFpbGVkUHJlY29uZGl0aW9uRXhjZXB0aW9uIGVycm9yLlxuICAgKi9cbiAgcHVibGljIGFzeW5jIGRpY3Rpb25hcnlJbmNyZW1lbnQoXG4gICAgY2FjaGVOYW1lOiBzdHJpbmcsXG4gICAgZGljdGlvbmFyeU5hbWU6IHN0cmluZyxcbiAgICBmaWVsZDogc3RyaW5nIHwgVWludDhBcnJheSxcbiAgICBhbW91bnQgPSAxLFxuICAgIG9wdGlvbnM/OiBEaWN0aW9uYXJ5SW5jcmVtZW50T3B0aW9uc1xuICApOiBQcm9taXNlPENhY2hlRGljdGlvbmFyeUluY3JlbWVudC5SZXNwb25zZT4ge1xuICAgIGNvbnN0IGNsaWVudCA9IHRoaXMuZ2V0TmV4dERhdGFDbGllbnQoKTtcbiAgICByZXR1cm4gYXdhaXQgY2xpZW50LmRpY3Rpb25hcnlJbmNyZW1lbnQoXG4gICAgICBjYWNoZU5hbWUsXG4gICAgICBkaWN0aW9uYXJ5TmFtZSxcbiAgICAgIGZpZWxkLFxuICAgICAgYW1vdW50LFxuICAgICAgb3B0aW9ucz8udHRsXG4gICAgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIHRoZSBudW1iZXIgb2YgZWxlbWVudHMgaW4gdGhlIGdpdmVuIGRpY3Rpb25hcnkuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBjYWNoZU5hbWUgLSBUaGUgY2FjaGUgY29udGFpbmluZyB0aGUgZGljdGlvbmFyeS5cbiAgICogQHBhcmFtIHtzdHJpbmd9IGRpY3Rpb25hcnlOYW1lIC0gVGhlIGRpY3Rpb25hcnkgdG8gZ2V0IHRoZSBsZW5ndGggb2YuXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPENhY2hlRGljdGlvbmFyeUxlbmd0aC5SZXNwb25zZT59IC1cbiAgICoge0BsaW5rIENhY2hlRGljdGlvbmFyeUxlbmd0aC5IaXR9IGNvbnRhaW5pbmcgdGhlIGxlbmd0aCBpZiB0aGUgZGljdGlvbmFyeSBleGlzdHMuXG4gICAqIHtAbGluayBDYWNoZURpY3Rpb25hcnlMZW5ndGguTWlzc30gaWYgdGhlIGRpY3Rpb25hcnkgZG9lcyBub3QgZXhpc3QuXG4gICAqIHtAbGluayBDYWNoZURpY3Rpb25hcnlMZW5ndGguRXJyb3J9IG9uIGZhaWx1cmUuXG4gICAqL1xuICBwdWJsaWMgYXN5bmMgZGljdGlvbmFyeUxlbmd0aChcbiAgICBjYWNoZU5hbWU6IHN0cmluZyxcbiAgICBkaWN0aW9uYXJ5TmFtZTogc3RyaW5nXG4gICk6IFByb21pc2U8Q2FjaGVEaWN0aW9uYXJ5TGVuZ3RoLlJlc3BvbnNlPiB7XG4gICAgY29uc3QgY2xpZW50ID0gdGhpcy5nZXROZXh0RGF0YUNsaWVudCgpO1xuICAgIHJldHVybiBhd2FpdCBjbGllbnQuZGljdGlvbmFyeUxlbmd0aChjYWNoZU5hbWUsIGRpY3Rpb25hcnlOYW1lKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBZGRzIGFuIGVsZW1lbnQgdG8gdGhlIGdpdmVuIHNvcnRlZCBzZXQuIElmIHRoZSBlbGVtZW50IGFscmVhZHkgZXhpc3RzLCBpdHNcbiAgICogc2NvcmUgaXMgdXBkYXRlZC4gQ3JlYXRlcyB0aGUgc29ydGVkIHNldCBpZiBpdCBkb2VzIG5vdCBleGlzdC5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IGNhY2hlTmFtZSAtIFRoZSBjYWNoZSBjb250YWluaW5nIHRoZSBzb3J0ZWQgc2V0LlxuICAgKiBAcGFyYW0ge3N0cmluZ30gc29ydGVkU2V0TmFtZSAtIFRoZSBzb3J0ZWQgc2V0IHRvIGFkZCB0by5cbiAgICogQHBhcmFtIHtzdHJpbmcgfCBVaW50OEFycmF5fSB2YWx1ZSAtIFRoZSB2YWx1ZSB0byBhZGQuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBzY29yZSAtIFRoZSBzY29yZSB0byBhc3NpZ24gdG8gdGhlIHZhbHVlLlxuICAgKiBAcGFyYW0ge1NvcnRlZFNldFB1dEVsZW1lbnRPcHRpb25zfSBvcHRpb25zXG4gICAqIEBwYXJhbSB7Q29sbGVjdGlvblR0bH0gW29wdGlvbnMudHRsXSAtIEhvdyB0aGUgVFRMIHNob3VsZCBiZSBtYW5hZ2VkLlxuICAgKiBSZWZyZXNoZXMgdGhlIHNvcnRlZCBzZXQncyBUVEwgdXNpbmcgdGhlIGNsaWVudCdzIGRlZmF1bHQgaWYgdGhpcyBpcyBub3RcbiAgICogc3VwcGxpZWQuXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPENhY2hlU29ydGVkU2V0UHV0RWxlbWVudC5SZXNwb25zZT59IC1cbiAgICoge0BsaW5rIENhY2hlU29ydGVkU2V0UHV0RWxlbWVudC5TdWNjZXNzfSBvbiBzdWNjZXNzLlxuICAgKiB7QGxpbmsgQ2FjaGVTb3J0ZWRTZXRQdXRFbGVtZW50LkVycm9yfSBvbiBmYWlsdXJlLlxuICAgKiBAcmV0dXJuc1xuICAgKi9cbiAgcHVibGljIGFzeW5jIHNvcnRlZFNldFB1dEVsZW1lbnQoXG4gICAgY2FjaGVOYW1lOiBzdHJpbmcsXG4gICAgc29ydGVkU2V0TmFtZTogc3RyaW5nLFxuICAgIHZhbHVlOiBzdHJpbmcgfCBVaW50OEFycmF5LFxuICAgIHNjb3JlOiBudW1iZXIsXG4gICAgb3B0aW9ucz86IFNvcnRlZFNldFB1dEVsZW1lbnRPcHRpb25zXG4gICk6IFByb21pc2U8Q2FjaGVTb3J0ZWRTZXRQdXRFbGVtZW50LlJlc3BvbnNlPiB7XG4gICAgY29uc3QgY2xpZW50ID0gdGhpcy5nZXROZXh0RGF0YUNsaWVudCgpO1xuICAgIHJldHVybiBhd2FpdCBjbGllbnQuc29ydGVkU2V0UHV0RWxlbWVudChcbiAgICAgIGNhY2hlTmFtZSxcbiAgICAgIHNvcnRlZFNldE5hbWUsXG4gICAgICB2YWx1ZSxcbiAgICAgIHNjb3JlLFxuICAgICAgb3B0aW9ucz8udHRsXG4gICAgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBZGRzIGVsZW1lbnRzIHRvIHRoZSBnaXZlbiBzb3J0ZWQgc2V0LiBGb3IgYW55IHZhbHVlcyB0aGF0IGFscmVhZHkgZXhpc3QsIGl0XG4gICAqIHRoZSBzY29yZSBpcyB1cGRhdGVkLiBDcmVhdGVzIHRoZSBzb3J0ZWQgc2V0IGlmIGl0IGRvZXMgbm90IGV4aXN0LlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gY2FjaGVOYW1lIC0gVGhlIGNhY2hlIGNvbnRhaW5pbmcgdGhlIHNvcnRlZCBzZXQuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBzb3J0ZWRTZXROYW1lIC0gVGhlIHNvcnRlZCBzZXQgdG8gYWRkIHRvLlxuICAgKiBAcGFyYW0ge01hcDxzdHJpbmcgfCBVaW50OEFycmF5LCBudW1iZXI+fCBSZWNvcmQ8c3RyaW5nLCBudW1iZXI+fSBlbGVtZW50cyAtIFRoZSB2YWx1ZS0+c2NvcmUgcGFpcnMgdG8gYWRkIHRvIHRoZSBzb3J0ZWQgc2V0LlxuICAgKiBAcGFyYW0ge1NvcnRlZFNldFB1dEVsZW1lbnRPcHRpb25zfSBvcHRpb25zXG4gICAqIEBwYXJhbSB7Q29sbGVjdGlvblR0bH0gW29wdGlvbnMudHRsXSAtIEhvdyB0aGUgVFRMIHNob3VsZCBiZSBtYW5hZ2VkLlxuICAgKiBSZWZyZXNoZXMgdGhlIHNvcnRlZCBzZXQncyBUVEwgdXNpbmcgdGhlIGNsaWVudCdzIGRlZmF1bHQgaWYgdGhpcyBpcyBub3RcbiAgICogc3VwcGxpZWQuXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPENhY2hlU29ydGVkU2V0UHV0RWxlbWVudHMuUmVzcG9uc2U+fSAtXG4gICAqIHtAbGluayBDYWNoZVNvcnRlZFNldFB1dEVsZW1lbnRzLlN1Y2Nlc3N9IG9uIHN1Y2Nlc3MuXG4gICAqIHtAbGluayBDYWNoZVNvcnRlZFNldFB1dEVsZW1lbnRzLkVycm9yfSBvbiBmYWlsdXJlLlxuICAgKiBAcmV0dXJuc1xuICAgKi9cbiAgcHVibGljIGFzeW5jIHNvcnRlZFNldFB1dEVsZW1lbnRzKFxuICAgIGNhY2hlTmFtZTogc3RyaW5nLFxuICAgIHNvcnRlZFNldE5hbWU6IHN0cmluZyxcbiAgICBlbGVtZW50czpcbiAgICAgIHwgTWFwPHN0cmluZyB8IFVpbnQ4QXJyYXksIG51bWJlcj5cbiAgICAgIHwgUmVjb3JkPHN0cmluZywgbnVtYmVyPlxuICAgICAgfCBBcnJheTxbc3RyaW5nLCBudW1iZXJdPixcbiAgICBvcHRpb25zPzogU29ydGVkU2V0UHV0RWxlbWVudHNPcHRpb25zXG4gICk6IFByb21pc2U8Q2FjaGVTb3J0ZWRTZXRQdXRFbGVtZW50cy5SZXNwb25zZT4ge1xuICAgIGNvbnN0IGNsaWVudCA9IHRoaXMuZ2V0TmV4dERhdGFDbGllbnQoKTtcbiAgICByZXR1cm4gYXdhaXQgY2xpZW50LnNvcnRlZFNldFB1dEVsZW1lbnRzKFxuICAgICAgY2FjaGVOYW1lLFxuICAgICAgc29ydGVkU2V0TmFtZSxcbiAgICAgIGVsZW1lbnRzLFxuICAgICAgb3B0aW9ucz8udHRsXG4gICAgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBGZXRjaCB0aGUgZWxlbWVudHMgaW4gdGhlIGdpdmVuIHNvcnRlZCBzZXQgYnkgaW5kZXggKHJhbmspLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gY2FjaGVOYW1lIC0gVGhlIGNhY2hlIGNvbnRhaW5pbmcgdGhlIHNvcnRlZCBzZXQuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBzb3J0ZWRTZXROYW1lIC0gVGhlIHNvcnRlZCBzZXQgdG8gZmV0Y2ggZnJvbS5cbiAgICogQHBhcmFtIHtTb3J0ZWRTZXRGZXRjaEJ5UmFua09wdGlvbnN9IG9wdGlvbnNcbiAgICogQHBhcmFtIHtudW1iZXJ9IFtvcHRpb25zLnN0YXJ0UmFua10gLSBUaGUgcmFuayBvZiB0aGUgZmlyc3QgZWxlbWVudCB0b1xuICAgKiBmZXRjaC4gRGVmYXVsdHMgdG8gMC4gVGhpcyByYW5rIGlzIGluY2x1c2l2ZSwgaWUgdGhlIGVsZW1lbnQgYXQgdGhpcyByYW5rXG4gICAqIHdpbGwgYmUgZmV0Y2hlZC5cbiAgICogQHBhcmFtIHtudW1iZXJ9IFtvcHRpb25zLmVuZFJhbmtdIC0gVGhlIHJhbmsgb2YgdGhlIGxhc3QgZWxlbWVudCB0byBmZXRjaC5cbiAgICogVGhpcyByYW5rIGlzIGV4Y2x1c2l2ZSwgaWUgdGhlIGVsZW1lbnQgYXQgdGhpcyByYW5rIHdpbGwgbm90IGJlIGZldGNoZWQuXG4gICAqIERlZmF1bHRzIHRvIG51bGwsIHdoaWNoIGZldGNoZXMgdXAgdW50aWwgYW5kIGluY2x1ZGluZyB0aGUgbGFzdCBlbGVtZW50LlxuICAgKiBAcGFyYW0ge1NvcnRlZFNldE9yZGVyfSBbb3B0aW9ucy5vcmRlcl0gLSBUaGUgb3JkZXIgdG8gZmV0Y2ggdGhlIGVsZW1lbnRzIGluLlxuICAgKiBEZWZhdWx0cyB0byBhc2NlbmRpbmcuXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPENhY2hlU29ydGVkU2V0RmV0Y2guUmVzcG9uc2U+fVxuICAgKiB7QGxpbmsgQ2FjaGVTb3J0ZWRTZXRGZXRjaC5IaXR9IGNvbnRhaW5pbmcgdGhlIHJlcXVlc3RlZCBlbGVtZW50cyB3aGVuIGZvdW5kLlxuICAgKiB7QGxpbmsgQ2FjaGVTb3J0ZWRTZXRGZXRjaC5NaXNzfSB3aGVuIHRoZSBzb3J0ZWQgc2V0IGRvZXMgbm90IGV4aXN0LlxuICAgKiB7QGxpbmsgQ2FjaGVTb3J0ZWRTZXRGZXRjaC5FcnJvcn0gb24gZmFpbHVyZS5cbiAgICovXG4gIHB1YmxpYyBhc3luYyBzb3J0ZWRTZXRGZXRjaEJ5UmFuayhcbiAgICBjYWNoZU5hbWU6IHN0cmluZyxcbiAgICBzb3J0ZWRTZXROYW1lOiBzdHJpbmcsXG4gICAgb3B0aW9ucz86IFNvcnRlZFNldEZldGNoQnlSYW5rT3B0aW9uc1xuICApOiBQcm9taXNlPENhY2hlU29ydGVkU2V0RmV0Y2guUmVzcG9uc2U+IHtcbiAgICBjb25zdCBjbGllbnQgPSB0aGlzLmdldE5leHREYXRhQ2xpZW50KCk7XG4gICAgcmV0dXJuIGF3YWl0IGNsaWVudC5zb3J0ZWRTZXRGZXRjaEJ5UmFuayhcbiAgICAgIGNhY2hlTmFtZSxcbiAgICAgIHNvcnRlZFNldE5hbWUsXG4gICAgICBvcHRpb25zPy5vcmRlciA/PyBTb3J0ZWRTZXRPcmRlci5Bc2NlbmRpbmcsXG4gICAgICBvcHRpb25zPy5zdGFydFJhbmsgPz8gMCxcbiAgICAgIG9wdGlvbnM/LmVuZFJhbmtcbiAgICApO1xuICB9XG5cbiAgLyoqXG4gICAqIEZldGNoIHRoZSBlbGVtZW50cyBpbiB0aGUgZ2l2ZW4gc29ydGVkIHNldCBieSBzY29yZS5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IGNhY2hlTmFtZSAtIFRoZSBjYWNoZSBjb250YWluaW5nIHRoZSBzb3J0ZWQgc2V0LlxuICAgKiBAcGFyYW0ge3N0cmluZ30gc29ydGVkU2V0TmFtZSAtIFRoZSBzb3J0ZWQgc2V0IHRvIGZldGNoIGZyb20uXG4gICAqIEBwYXJhbSB7U29ydGVkU2V0RmV0Y2hCeVNjb3JlT3B0aW9uc30gb3B0aW9uc1xuICAgKiBAcGFyYW0ge251bWJlcn0gW29wdGlvbnMubWluU2NvcmVdIC0gVGhlIG1pbmltdW0gc2NvcmUgKGluY2x1c2l2ZSkgb2YgdGhlXG4gICAqIGVsZW1lbnRzIHRvIGZldGNoLiBEZWZhdWx0cyB0byBuZWdhdGl2ZSBpbmZpbml0eS5cbiAgICogQHBhcmFtIHtudW1iZXJ9IFtvcHRpb25zLm1heFNjb3JlXSAtIFRoZSBtYXhpbXVtIHNjb3JlIChpbmNsdXNpdmUpIG9mIHRoZVxuICAgKiBlbGVtZW50cyB0byBmZXRjaC4gRGVmYXVsdHMgdG8gcG9zaXRpdmUgaW5maW5pdHkuXG4gICAqIEBwYXJhbSB7U29ydGVkU2V0T3JkZXJ9IFtvcHRpb25zLm9yZGVyXSAtIFRoZSBvcmRlciB0byBmZXRjaCB0aGUgZWxlbWVudHMgaW4uXG4gICAqIERlZmF1bHRzIHRvIGFzY2VuZGluZy5cbiAgICogQHBhcmFtIHtudW1iZXJ9IFtvcHRpb25zLm9mZnNldF0gLSBUaGUgbnVtYmVyIG9mIGVsZW1lbnRzIHRvIHNraXAgYmVmb3JlXG4gICAqIHJldHVybmluZyB0aGUgZmlyc3QgZWxlbWVudC4gRGVmYXVsdHMgdG8gMC4gTm90ZTogdGhpcyBpcyBub3QgdGhlIHJhbmsgb2ZcbiAgICogdGhlIGZpcnN0IGVsZW1lbnQgdG8gcmV0dXJuLCBidXQgdGhlIG51bWJlciBvZiBlbGVtZW50cyBvZiB0aGUgcmVzdWx0IHNldFxuICAgKiB0byBza2lwIGJlZm9yZSByZXR1cm5pbmcgdGhlIGZpcnN0IGVsZW1lbnQuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0aW9ucy5jb3VudF0gLSBUaGUgbWF4aW11bSBudW1iZXIgb2YgZWxlbWVudHMgdG8gcmV0dXJuLlxuICAgKiBEZWZhdWx0cyB0byB1bmRlZmluZWQsIHdoaWNoIHJldHVybnMgYWxsIGVsZW1lbnRzLlxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxDYWNoZVNvcnRlZFNldEZldGNoLlJlc3BvbnNlPn0gLVxuICAgKiB7QGxpbmsgQ2FjaGVTb3J0ZWRTZXRGZXRjaC5IaXR9IGNvbnRhaW5pbmcgdGhlIHJlcXVlc3RlZCBlbGVtZW50cyB3aGVuIGZvdW5kLlxuICAgKiB7QGxpbmsgQ2FjaGVTb3J0ZWRTZXRGZXRjaC5NaXNzfSB3aGVuIHRoZSBzb3J0ZWQgc2V0IGRvZXMgbm90IGV4aXN0LlxuICAgKiB7QGxpbmsgQ2FjaGVTb3J0ZWRTZXRGZXRjaC5FcnJvcn0gb24gZmFpbHVyZS5cbiAgICovXG4gIHB1YmxpYyBhc3luYyBzb3J0ZWRTZXRGZXRjaEJ5U2NvcmUoXG4gICAgY2FjaGVOYW1lOiBzdHJpbmcsXG4gICAgc29ydGVkU2V0TmFtZTogc3RyaW5nLFxuICAgIG9wdGlvbnM/OiBTb3J0ZWRTZXRGZXRjaEJ5U2NvcmVPcHRpb25zXG4gICk6IFByb21pc2U8Q2FjaGVTb3J0ZWRTZXRGZXRjaC5SZXNwb25zZT4ge1xuICAgIGNvbnN0IGNsaWVudCA9IHRoaXMuZ2V0TmV4dERhdGFDbGllbnQoKTtcbiAgICByZXR1cm4gYXdhaXQgY2xpZW50LnNvcnRlZFNldEZldGNoQnlTY29yZShcbiAgICAgIGNhY2hlTmFtZSxcbiAgICAgIHNvcnRlZFNldE5hbWUsXG4gICAgICBvcHRpb25zPy5vcmRlciA/PyBTb3J0ZWRTZXRPcmRlci5Bc2NlbmRpbmcsXG4gICAgICBvcHRpb25zPy5taW5TY29yZSxcbiAgICAgIG9wdGlvbnM/Lm1heFNjb3JlLFxuICAgICAgb3B0aW9ucz8ub2Zmc2V0LFxuICAgICAgb3B0aW9ucz8uY291bnRcbiAgICApO1xuICB9XG5cbiAgLyoqXG4gICAqIExvb2sgdXAgdGhlIHJhbmsgb2YgYW4gZWxlbWVudCBpbiB0aGUgc29ydGVkIHNldCwgYnkgdGhlIHZhbHVlIG9mIHRoZSBlbGVtZW50LlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gY2FjaGVOYW1lIC0gVGhlIGNhY2hlIGNvbnRhaW5pbmcgdGhlIHNvcnRlZCBzZXQuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBzb3J0ZWRTZXROYW1lIC0gVGhlIHNvcnRlZCBzZXQgdG8gZmV0Y2ggZnJvbS5cbiAgICogQHBhcmFtIHtzdHJpbmcgfCBVaW50OEFycmF5fSB2YWx1ZSAtIFRoZSB2YWx1ZSBvZiB0aGUgZWxlbWVudCB3aG9zZSByYW5rIHdlIGFyZSByZXRyaWV2aW5nLlxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxDYWNoZVNvcnRlZFNldEdldFJhbmsuUmVzcG9uc2U+fVxuICAgKiB7QGxpbmsgQ2FjaGVTb3J0ZWRTZXRHZXRSYW5rLkhpdH0gY29udGFpbmluZyB0aGUgcmFuayBvZiB0aGUgcmVxdWVzdGVkIGVsZW1lbnRzIHdoZW4gZm91bmQuXG4gICAqIHtAbGluayBDYWNoZVNvcnRlZFNldEdldFJhbmsuTWlzc30gd2hlbiB0aGUgZWxlbWVudCBkb2VzIG5vdCBleGlzdC5cbiAgICoge0BsaW5rIENhY2hlU29ydGVkU2V0R2V0UmFuay5FcnJvcn0gb24gZmFpbHVyZS5cbiAgICovXG4gIHB1YmxpYyBhc3luYyBzb3J0ZWRTZXRHZXRSYW5rKFxuICAgIGNhY2hlTmFtZTogc3RyaW5nLFxuICAgIHNvcnRlZFNldE5hbWU6IHN0cmluZyxcbiAgICB2YWx1ZTogc3RyaW5nIHwgVWludDhBcnJheVxuICApOiBQcm9taXNlPENhY2hlU29ydGVkU2V0R2V0UmFuay5SZXNwb25zZT4ge1xuICAgIGNvbnN0IGNsaWVudCA9IHRoaXMuZ2V0TmV4dERhdGFDbGllbnQoKTtcbiAgICByZXR1cm4gYXdhaXQgY2xpZW50LnNvcnRlZFNldEdldFJhbmsoY2FjaGVOYW1lLCBzb3J0ZWRTZXROYW1lLCB2YWx1ZSk7XG4gIH1cblxuICAvKipcbiAgICogTG9vayB1cCB0aGUgc2NvcmUgb2YgYW4gZWxlbWVudCBpbiB0aGUgc29ydGVkIHNldCwgYnkgdGhlIHZhbHVlIG9mIHRoZSBlbGVtZW50LlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gY2FjaGVOYW1lIC0gVGhlIGNhY2hlIGNvbnRhaW5pbmcgdGhlIHNvcnRlZCBzZXQuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBzb3J0ZWRTZXROYW1lIC0gVGhlIHNvcnRlZCBzZXQgdG8gZmV0Y2ggZnJvbS5cbiAgICogQHBhcmFtIHtzdHJpbmcgfCBVaW50OEFycmF5fSB2YWx1ZSAtIFRoZSB2YWx1ZSBvZiB0aGUgZWxlbWVudCB3aG9zZSBzY29yZSB3ZSBhcmUgcmV0cmlldmluZy5cbiAgICogQHJldHVybnMge1Byb21pc2U8Q2FjaGVTb3J0ZWRTZXRHZXRTY29yZS5SZXNwb25zZT59XG4gICAqIHtAbGluayBDYWNoZVNvcnRlZFNldEdldFNjb3JlLkhpdH0gY29udGFpbmluZyB0aGUgc2NvcmUgb2YgdGhlIHJlcXVlc3RlZCBlbGVtZW50IHdoZW4gZm91bmQuXG4gICAqIHtAbGluayBDYWNoZVNvcnRlZFNldEdldFNjb3JlLk1pc3N9IHdoZW4gdGhlIGVsZW1lbnQgb3IgY29sbGVjdGlvbiBkb2VzIG5vdCBleGlzdC5cbiAgICoge0BsaW5rIENhY2hlU29ydGVkU2V0R2V0U2NvcmUuRXJyb3J9IG9uIGZhaWx1cmUuXG4gICAqL1xuICBwdWJsaWMgYXN5bmMgc29ydGVkU2V0R2V0U2NvcmUoXG4gICAgY2FjaGVOYW1lOiBzdHJpbmcsXG4gICAgc29ydGVkU2V0TmFtZTogc3RyaW5nLFxuICAgIHZhbHVlOiBzdHJpbmcgfCBVaW50OEFycmF5XG4gICk6IFByb21pc2U8Q2FjaGVTb3J0ZWRTZXRHZXRTY29yZS5SZXNwb25zZT4ge1xuICAgIGNvbnN0IGNsaWVudCA9IHRoaXMuZ2V0TmV4dERhdGFDbGllbnQoKTtcbiAgICByZXR1cm4gYXdhaXQgY2xpZW50LnNvcnRlZFNldEdldFNjb3JlKGNhY2hlTmFtZSwgc29ydGVkU2V0TmFtZSwgdmFsdWUpO1xuICB9XG5cbiAgLyoqXG4gICAqIExvb2sgdXAgdGhlIHNjb3JlcyBvZiBtdWx0aXBsZSBlbGVtZW50cyBpbiB0aGUgc29ydGVkIHNldCwgYnkgdGhlIHZhbHVlIG9mIHRoZSBlbGVtZW50cy5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IGNhY2hlTmFtZSAtIFRoZSBjYWNoZSBjb250YWluaW5nIHRoZSBzb3J0ZWQgc2V0LlxuICAgKiBAcGFyYW0ge3N0cmluZ30gc29ydGVkU2V0TmFtZSAtIFRoZSBzb3J0ZWQgc2V0IHRvIGZldGNoIGZyb20uXG4gICAqIEBwYXJhbSB7c3RyaW5nW10gfCBVaW50OEFycmF5W119IHZhbHVlcyAtIFRoZSB2YWx1ZXMgb2YgdGhlIGVsZW1lbnRzIHdob3NlIHNjb3JlcyB3ZSBhcmUgcmV0cmlldmluZy5cbiAgICogQHJldHVybnMge1Byb21pc2U8Q2FjaGVTb3J0ZWRTZXRHZXRTY29yZXMuUmVzcG9uc2U+fVxuICAgKiB7QGxpbmsgQ2FjaGVTb3J0ZWRTZXRHZXRTY29yZXMuSGl0fSBjb250YWluaW5nIHRoZSBzY29yZXMgb2YgdGhlIHJlcXVlc3RlZCBlbGVtZW50cyB3aGVuIGZvdW5kLlxuICAgKiB7QGxpbmsgQ2FjaGVTb3J0ZWRTZXRHZXRTY29yZXMuTWlzc30gd2hlbiB0aGUgZWxlbWVudCBvciBjb2xsZWN0aW9uIGRvZXMgbm90IGV4aXN0LlxuICAgKiB7QGxpbmsgQ2FjaGVTb3J0ZWRTZXRHZXRTY29yZXMuRXJyb3J9IG9uIGZhaWx1cmUuXG4gICAqL1xuICBwdWJsaWMgYXN5bmMgc29ydGVkU2V0R2V0U2NvcmVzKFxuICAgIGNhY2hlTmFtZTogc3RyaW5nLFxuICAgIHNvcnRlZFNldE5hbWU6IHN0cmluZyxcbiAgICB2YWx1ZXM6IHN0cmluZ1tdIHwgVWludDhBcnJheVtdXG4gICk6IFByb21pc2U8Q2FjaGVTb3J0ZWRTZXRHZXRTY29yZXMuUmVzcG9uc2U+IHtcbiAgICBjb25zdCBjbGllbnQgPSB0aGlzLmdldE5leHREYXRhQ2xpZW50KCk7XG4gICAgcmV0dXJuIGF3YWl0IGNsaWVudC5zb3J0ZWRTZXRHZXRTY29yZXMoY2FjaGVOYW1lLCBzb3J0ZWRTZXROYW1lLCB2YWx1ZXMpO1xuICB9XG5cbiAgLyoqXG4gICAqIEluY3JlbWVudCB0aGUgc2NvcmUgb2YgYW4gZWxlbWVudCBpbiB0aGUgc29ydGVkIHNldC5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IGNhY2hlTmFtZSAtIFRoZSBjYWNoZSBjb250YWluaW5nIHRoZSBzb3J0ZWQgc2V0LlxuICAgKiBAcGFyYW0ge3N0cmluZ30gc29ydGVkU2V0TmFtZSAtIFRoZSBzb3J0ZWQgc2V0IHRvIGZldGNoIGZyb20uXG4gICAqIEBwYXJhbSB7c3RyaW5nIHwgVWludDhBcnJheX0gdmFsdWUgLSBUaGUgdmFsdWUgb2YgdGhlIGVsZW1lbnQgd2hvc2Ugc2NvcmUgd2UgYXJlIGluY3JlbWVudGluZy5cbiAgICogQHBhcmFtIHtudW1iZXJ9IGFtb3VudCAtIFRoZSBxdWFudGl0eSB0byBhZGQgdG8gdGhlIHNjb3JlLiBNYXkgYmUgcG9zaXRpdmUsXG4gICAqIG5lZ2F0aXZlLCBvciB6ZXJvLiBEZWZhdWx0cyB0byAxLlxuICAgKiBAcGFyYW0ge1NvcnRlZFNldEluY3JlbWVudE9wdGlvbnN9IG9wdGlvbnNcbiAgICogQHBhcmFtIHtDb2xsZWN0aW9uVHRsfSBbb3B0aW9ucy50dGxdIC0gSG93IHRoZSBUVEwgc2hvdWxkIGJlIG1hbmFnZWQuXG4gICAqIFJlZnJlc2hlcyB0aGUgc29ydGVkIHNldCdzIFRUTCB1c2luZyB0aGUgY2xpZW50J3MgZGVmYXVsdCBpZiB0aGlzIGlzIG5vdFxuICAgKiBzdXBwbGllZC5cbiAgICogQHJldHVybnMge1Byb21pc2U8Q2FjaGVTb3J0ZWRTZXRJbmNyZW1lbnRTY29yZS5SZXNwb25zZT59IC1cbiAgICoge0BsaW5rIENhY2hlU29ydGVkU2V0SW5jcmVtZW50U2NvcmUuU3VjY2Vzc30gY29udGFpbmluZyB0aGUgaW5jcmVtZW50ZWQgc2NvcmVcbiAgICogb24gc3VjY2Vzcy5cbiAgICoge0BsaW5rIENhY2hlU29ydGVkU2V0SW5jcmVtZW50U2NvcmUuRXJyb3J9IG9uIGZhaWx1cmUuIEluY3JlbWVudGluZyBhIHNjb3JlXG4gICAqIHRoYXQgd2FzIG5vdCBzZXQgdXNpbmcgdGhpcyBtZXRob2Qgb3IgaXMgbm90IHRoZSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2ZcbiAgICogYW4gaW50ZWdlciByZXN1bHRzIGluIGEgZmFpbHVyZSB3aXRoIGEgRmFpbGVkUHJlY29uZGl0aW9uRXhjZXB0aW9uIGVycm9yLlxuICAgKi9cbiAgcHVibGljIGFzeW5jIHNvcnRlZFNldEluY3JlbWVudFNjb3JlKFxuICAgIGNhY2hlTmFtZTogc3RyaW5nLFxuICAgIHNvcnRlZFNldE5hbWU6IHN0cmluZyxcbiAgICB2YWx1ZTogc3RyaW5nIHwgVWludDhBcnJheSxcbiAgICBhbW91bnQ/OiBudW1iZXIsXG4gICAgb3B0aW9ucz86IFNvcnRlZFNldEluY3JlbWVudE9wdGlvbnNcbiAgKTogUHJvbWlzZTxDYWNoZVNvcnRlZFNldEluY3JlbWVudFNjb3JlLlJlc3BvbnNlPiB7XG4gICAgY29uc3QgY2xpZW50ID0gdGhpcy5nZXROZXh0RGF0YUNsaWVudCgpO1xuICAgIHJldHVybiBhd2FpdCBjbGllbnQuc29ydGVkU2V0SW5jcmVtZW50U2NvcmUoXG4gICAgICBjYWNoZU5hbWUsXG4gICAgICBzb3J0ZWRTZXROYW1lLFxuICAgICAgdmFsdWUsXG4gICAgICBhbW91bnQgfHwgMSxcbiAgICAgIG9wdGlvbnM/LnR0bFxuICAgICk7XG4gIH1cblxuICAvKipcbiAgICogUmVtb3ZlIGFuIGVsZW1lbnQgZnJvbSB0aGUgc29ydGVkIHNldFxuICAgKiBAcGFyYW0ge3N0cmluZ30gY2FjaGVOYW1lIC0gVGhlIGNhY2hlIGNvbnRhaW5pbmcgdGhlIHNvcnRlZCBzZXQuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBzb3J0ZWRTZXROYW1lIC0gVGhlIHNvcnRlZCBzZXQgdG8gcmVtb3ZlIGZyb20uXG4gICAqIEBwYXJhbSB7c3RyaW5nIHwgVWludDhBcnJheX0gdmFsdWUgLSBUaGUgdmFsdWUgb2YgdGhlIGVsZW1lbnQgdG8gcmVtb3ZlIGZyb20gdGhlIHNldC5cbiAgICogQHJldHVybnMge1Byb21pc2U8Q2FjaGVTb3J0ZWRTZXRSZW1vdmVFbGVtZW50LlJlc3BvbnNlPn1cbiAgICoge0BsaW5rIENhY2hlU29ydGVkU2V0UmVtb3ZlRWxlbWVudC5TdWNjZXNzfSBpZiB0aGUgZWxlbWVudCB3YXMgc3VjY2Vzc2Z1bGx5IHJlbW92ZWRcbiAgICoge0BsaW5rIENhY2hlU29ydGVkU2V0SW5jcmVtZW50U2NvcmUuRXJyb3J9IG9uIGZhaWx1cmVcbiAgICovXG4gIHB1YmxpYyBhc3luYyBzb3J0ZWRTZXRSZW1vdmVFbGVtZW50KFxuICAgIGNhY2hlTmFtZTogc3RyaW5nLFxuICAgIHNvcnRlZFNldE5hbWU6IHN0cmluZyxcbiAgICB2YWx1ZTogc3RyaW5nIHwgVWludDhBcnJheVxuICApOiBQcm9taXNlPENhY2hlU29ydGVkU2V0UmVtb3ZlRWxlbWVudC5SZXNwb25zZT4ge1xuICAgIGNvbnN0IGNsaWVudCA9IHRoaXMuZ2V0TmV4dERhdGFDbGllbnQoKTtcbiAgICByZXR1cm4gYXdhaXQgY2xpZW50LnNvcnRlZFNldFJlbW92ZUVsZW1lbnQoY2FjaGVOYW1lLCBzb3J0ZWRTZXROYW1lLCB2YWx1ZSk7XG4gIH1cblxuICAvKipcbiAgICogUmVtb3ZlIG11bHRpcGxlIGVsZW1lbnRzIGZyb20gdGhlIHNvcnRlZCBzZXRcbiAgICogQHBhcmFtIHtzdHJpbmd9IGNhY2hlTmFtZSAtIFRoZSBjYWNoZSBjb250YWluaW5nIHRoZSBzb3J0ZWQgc2V0LlxuICAgKiBAcGFyYW0ge3N0cmluZ30gc29ydGVkU2V0TmFtZSAtIFRoZSBzb3J0ZWQgc2V0IHRvIHJlbW92ZSBmcm9tLlxuICAgKiBAcGFyYW0ge3N0cmluZyB8IFVpbnQ4QXJyYXl9IHZhbHVlcyAtIFRoZSB2YWx1ZXMgb2YgdGhlIGVsZW1lbnRzIHRvIHJlbW92ZSBmcm9tIHRoZSBzZXQuXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPENhY2hlU29ydGVkU2V0UmVtb3ZlRWxlbWVudC5SZXNwb25zZT59XG4gICAqIHtAbGluayBDYWNoZVNvcnRlZFNldFJlbW92ZUVsZW1lbnQuU3VjY2Vzc30gaWYgdGhlIGVsZW1lbnRzIHdlcmUgc3VjY2Vzc2Z1bGx5IHJlbW92ZWRcbiAgICoge0BsaW5rIENhY2hlU29ydGVkU2V0SW5jcmVtZW50U2NvcmUuRXJyb3J9IG9uIGZhaWx1cmVcbiAgICovXG4gIHB1YmxpYyBhc3luYyBzb3J0ZWRTZXRSZW1vdmVFbGVtZW50cyhcbiAgICBjYWNoZU5hbWU6IHN0cmluZyxcbiAgICBzb3J0ZWRTZXROYW1lOiBzdHJpbmcsXG4gICAgdmFsdWVzOiBzdHJpbmdbXSB8IFVpbnQ4QXJyYXlbXVxuICApOiBQcm9taXNlPENhY2hlU29ydGVkU2V0UmVtb3ZlRWxlbWVudHMuUmVzcG9uc2U+IHtcbiAgICBjb25zdCBjbGllbnQgPSB0aGlzLmdldE5leHREYXRhQ2xpZW50KCk7XG4gICAgcmV0dXJuIGF3YWl0IGNsaWVudC5zb3J0ZWRTZXRSZW1vdmVFbGVtZW50cyhcbiAgICAgIGNhY2hlTmFtZSxcbiAgICAgIHNvcnRlZFNldE5hbWUsXG4gICAgICB2YWx1ZXNcbiAgICApO1xuICB9XG5cbiAgLyoqXG4gICAqIEZldGNoIGxlbmd0aCAobnVtYmVyIG9mIGl0ZW1zKSBvZiBzb3J0ZWQgc2V0XG4gICAqIEBwYXJhbSB7c3RyaW5nfSBjYWNoZU5hbWUgLSBUaGUgY2FjaGUgY29udGFpbmluZyB0aGUgc29ydGVkIHNldC5cbiAgICogQHBhcmFtIHtzdHJpbmd9IHNvcnRlZFNldE5hbWUgLSBUaGUgc29ydGVkIHNldCBuYW1lLlxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxDYWNoZVNvcnRlZFNldExlbmd0aC5SZXNwb25zZT59XG4gICAqIHtAbGluayBDYWNoZVNvcnRlZFNldExlbmd0aC5IaXR9IGNvbnRhaW5pbmcgdGhlIGxlbmd0aCBpZiB0aGUgc29ydGVkIHNldCBleGlzdHMuXG4gICAqIHtAbGluayBDYWNoZVNvcnRlZFNldExlbmd0aC5NaXNzfSBpZiB0aGUgc29ydGVkIHNldCBkb2VzIG5vdCBleGlzdC5cbiAgICoge0BsaW5rIENhY2hlU29ydGVkU2V0TGVuZ3RoLkVycm9yfSBvbiBmYWlsdXJlLlxuICAgKi9cbiAgcHVibGljIGFzeW5jIHNvcnRlZFNldExlbmd0aChcbiAgICBjYWNoZU5hbWU6IHN0cmluZyxcbiAgICBzb3J0ZWRTZXROYW1lOiBzdHJpbmdcbiAgKTogUHJvbWlzZTxDYWNoZVNvcnRlZFNldExlbmd0aC5SZXNwb25zZT4ge1xuICAgIGNvbnN0IGNsaWVudCA9IHRoaXMuZ2V0TmV4dERhdGFDbGllbnQoKTtcbiAgICByZXR1cm4gYXdhaXQgY2xpZW50LnNvcnRlZFNldExlbmd0aChjYWNoZU5hbWUsIHNvcnRlZFNldE5hbWUpO1xuICB9XG5cbiAgLyoqXG4gICAqIEZldGNoIGxlbmd0aCAobnVtYmVyIG9mIGl0ZW1zKSBvZiBzb3J0ZWQgc2V0IHdpdGhpbiB0aGUgcHJvdmlkZWQgc2NvcmUgcmFuZ2VcbiAgICogQHBhcmFtIHtzdHJpbmd9IGNhY2hlTmFtZSAtIFRoZSBjYWNoZSBjb250YWluaW5nIHRoZSBzb3J0ZWQgc2V0LlxuICAgKiBAcGFyYW0ge3N0cmluZ30gc29ydGVkU2V0TmFtZSAtIFRoZSBzb3J0ZWQgc2V0IG5hbWUuXG4gICAqIEBwYXJhbSB7U29ydGVkU2V0TGVuZ3RoQnlTY29yZU9wdGlvbnN9IG9wdGlvbnMgLSBPcHRpb25hbCBwYXJhbWV0ZXIgZm9yIHNwZWNpZnlpbmcgdGhlIHNjb3JlIHJhbmdlIHRvIHNlYXJjaCBpbi5cbiAgICogQHBhcmFtIHtudW1iZXJ9IFtvcHRpb25zLm1pblNjb3JlXSAtIFRoZSBsb3dlciBib3VuZCBvbiB0aGUgc2NvcmUgcmFuZ2UgdG8gc2VhcmNoIGluLlxuICAgKiBAcGFyYW0ge251bWJlcn0gW29wdGlvbnMubWF4U2NvcmVdIC0gVGhlIHVwcGVyIGJvdW5kIG9uIHRoZSBzY29yZSByYW5nZSB0byBzZWFyY2ggaW4uXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPENhY2hlU29ydGVkU2V0TGVuZ3RoQnlTY29yZS5SZXNwb25zZT59XG4gICAqIHtAbGluayBDYWNoZVNvcnRlZFNldExlbmd0aEJ5U2NvcmUuSGl0fSBjb250YWluaW5nIHRoZSBsZW5ndGggaWYgdGhlIHNvcnRlZCBzZXQgZXhpc3RzLlxuICAgKiB7QGxpbmsgQ2FjaGVTb3J0ZWRTZXRMZW5ndGhCeVNjb3JlLk1pc3N9IGlmIHRoZSBzb3J0ZWQgc2V0IGRvZXMgbm90IGV4aXN0LlxuICAgKiB7QGxpbmsgQ2FjaGVTb3J0ZWRTZXRMZW5ndGhCeVNjb3JlLkVycm9yfSBvbiBmYWlsdXJlLlxuICAgKi9cbiAgcHVibGljIGFzeW5jIHNvcnRlZFNldExlbmd0aEJ5U2NvcmUoXG4gICAgY2FjaGVOYW1lOiBzdHJpbmcsXG4gICAgc29ydGVkU2V0TmFtZTogc3RyaW5nLFxuICAgIG9wdGlvbnM/OiBTb3J0ZWRTZXRMZW5ndGhCeVNjb3JlT3B0aW9uc1xuICApOiBQcm9taXNlPENhY2hlU29ydGVkU2V0TGVuZ3RoQnlTY29yZS5SZXNwb25zZT4ge1xuICAgIGNvbnN0IGNsaWVudCA9IHRoaXMuZ2V0TmV4dERhdGFDbGllbnQoKTtcbiAgICByZXR1cm4gYXdhaXQgY2xpZW50LnNvcnRlZFNldExlbmd0aEJ5U2NvcmUoXG4gICAgICBjYWNoZU5hbWUsXG4gICAgICBzb3J0ZWRTZXROYW1lLFxuICAgICAgb3B0aW9ucz8ubWluU2NvcmUsXG4gICAgICBvcHRpb25zPy5tYXhTY29yZVxuICAgICk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJuIHRoZSB0eXBlIG9mIHRoZSBrZXkgaW4gdGhlIGNhY2hlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBjYWNoZU5hbWUgLSBUaGUgY2FjaGUgY29udGFpbmluZyB0aGUga2V5LlxuICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IC0gVGhlIGtleSBmb3Igd2hpY2ggdHlwZSBpcyByZXF1ZXN0ZWQuXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPENhY2hlSXRlbUdldFR5cGUuUmVzcG9uc2U+fVxuICAgKiB7QGxpbmsgQ2FjaGVJdGVtR2V0VHlwZS5IaXR9IGNvbnRhaW5pbmcgdHlwZSBvZiBrZXkgd2hlbiBmb3VuZC5cbiAgICoge0BsaW5rIENhY2hlSXRlbUdldFR5cGUuTWlzc30gd2hlbiB0aGUga2V5IGRvZXMgbm90IGV4aXN0LlxuICAgKiB7QGxpbmsgQ2FjaGVJdGVtR2V0VHlwZS5FcnJvcn0gb24gZmFpbHVyZS5cbiAgICovXG4gIHB1YmxpYyBhc3luYyBpdGVtR2V0VHlwZShcbiAgICBjYWNoZU5hbWU6IHN0cmluZyxcbiAgICBrZXk6IHN0cmluZyB8IFVpbnQ4QXJyYXlcbiAgKTogUHJvbWlzZTxDYWNoZUl0ZW1HZXRUeXBlLlJlc3BvbnNlPiB7XG4gICAgY29uc3QgY2xpZW50ID0gdGhpcy5nZXROZXh0RGF0YUNsaWVudCgpO1xuICAgIHJldHVybiBhd2FpdCBjbGllbnQuaXRlbUdldFR5cGUoY2FjaGVOYW1lLCBrZXkpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybiB0aGUgcmVtYWluaW5nIHR0bCBvZiB0aGUga2V5IGluIHRoZSBjYWNoZSBpbiBtaWxsaXNlY29uZHMuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBjYWNoZU5hbWUgLSBUaGUgY2FjaGUgY29udGFpbmluZyB0aGUga2V5LlxuICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IC0gVGhlIGtleSBmb3Igd2hpY2ggdGhlIHR0bCByZW1haW5pbmcgaXMgcmVxdWVzdGVkLlxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxDYWNoZUl0ZW1HZXRUdGwuUmVzcG9uc2U+fVxuICAgKiB7QGxpbmsgQ2FjaGVJdGVtR2V0VHRsLkhpdH0gY29udGFpbmluZyB0dGwgcmVtYWluaW5nIG9mIGtleSB3aGVuIGZvdW5kLlxuICAgKiB7QGxpbmsgQ2FjaGVJdGVtR2V0VHRsLk1pc3N9IHdoZW4gdGhlIGtleSBkb2VzIG5vdCBleGlzdC5cbiAgICoge0BsaW5rIENhY2hlSXRlbUdldFR0bC5FcnJvcn0gb24gZmFpbHVyZS5cbiAgICovXG4gIHB1YmxpYyBhc3luYyBpdGVtR2V0VHRsKFxuICAgIGNhY2hlTmFtZTogc3RyaW5nLFxuICAgIGtleTogc3RyaW5nIHwgVWludDhBcnJheVxuICApOiBQcm9taXNlPENhY2hlSXRlbUdldFR0bC5SZXNwb25zZT4ge1xuICAgIGNvbnN0IGNsaWVudCA9IHRoaXMuZ2V0TmV4dERhdGFDbGllbnQoKTtcbiAgICByZXR1cm4gYXdhaXQgY2xpZW50Lml0ZW1HZXRUdGwoY2FjaGVOYW1lLCBrZXkpO1xuICB9XG5cbiAgLyoqXG4gICAqIENoZWNrIGlmIHRoZSBwcm92aWRlZCBrZXkgZXhpc3RzIGluIHRoZSBjYWNoZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gY2FjaGVOYW1lIC0gVGhlIGNhY2hlIHRvIGxvb2sgaW4uXG4gICAqIEBwYXJhbSB7c3RyaW5nIHwgVWludDhBcnJheX0ga2V5IC0gVGhlIGtleSB0byBsb29rIHVwLlxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxDYWNoZUtleUV4aXN0cy5SZXNwb25zZT59XG4gICAqIHtAbGluayBDYWNoZUtleUV4aXN0cy5TdWNjZXNzfSBpZiBrZXkgaXMgZm91bmQ/IG9yIGlmIGtleSBpcyBjaGVja2VkP1xuICAgKiB7QGxpbmsgQ2FjaGVLZXlFeGlzdHMuRXJyb3J9IG9uIGZhaWx1cmUuXG4gICAqL1xuICBwdWJsaWMgYXN5bmMga2V5RXhpc3RzKFxuICAgIGNhY2hlTmFtZTogc3RyaW5nLFxuICAgIGtleTogc3RyaW5nIHwgVWludDhBcnJheVxuICApOiBQcm9taXNlPENhY2hlS2V5RXhpc3RzLlJlc3BvbnNlPiB7XG4gICAgY29uc3QgY2xpZW50ID0gdGhpcy5nZXROZXh0RGF0YUNsaWVudCgpO1xuICAgIHJldHVybiBhd2FpdCBjbGllbnQua2V5RXhpc3RzKGNhY2hlTmFtZSwga2V5KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDaGVjayBpZiB0aGUgcHJvdmlkZWQga2V5cyBleGlzdCBpbiB0aGUgY2FjaGVcbiAgICogQHBhcmFtIHtzdHJpbmd9IGNhY2hlTmFtZSAtIFRoZSBjYWNoZSB0byBsb29rIGluLlxuICAgKiBAcGFyYW0ge3N0cmluZ1tdIHwgVWludDhBcnJheVtdfSBrZXlzIC0gVGhlIGtleXMgdG8gbG9vayB1cC5cbiAgICogQHJldHVybnMge1Byb21pc2U8Q2FjaGVLZXlzRXhpc3QuUmVzcG9uc2U+fVxuICAgKiB7QGxpbmsgQ2FjaGVLZXlzRXhpc3QuU3VjY2Vzc30gaWYgYXQgbGVhc3Qgb25lIGtleSBpcyBmb3VuZD8gaWYgYWxsIGtleXMgY2hlY2tlZD9cbiAgICoge0BsaW5rIENhY2hlS2V5c0V4aXN0LkVycm9yfSBvbiBmYWlsdXJlLlxuICAgKi9cbiAgcHVibGljIGFzeW5jIGtleXNFeGlzdChcbiAgICBjYWNoZU5hbWU6IHN0cmluZyxcbiAgICBrZXlzOiBzdHJpbmdbXSB8IFVpbnQ4QXJyYXlbXVxuICApOiBQcm9taXNlPENhY2hlS2V5c0V4aXN0LlJlc3BvbnNlPiB7XG4gICAgY29uc3QgY2xpZW50ID0gdGhpcy5nZXROZXh0RGF0YUNsaWVudCgpO1xuICAgIHJldHVybiBhd2FpdCBjbGllbnQua2V5c0V4aXN0KGNhY2hlTmFtZSwga2V5cyk7XG4gIH1cblxuICAvKipcbiAgICogVXBkYXRlIHRoZSB0dGwgb2YgdGhlIGtleSBpbiB0aGUgY2FjaGUgaW4gbWlsbGlzZWNvbmRzLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gY2FjaGVOYW1lIC0gVGhlIGNhY2hlIGNvbnRhaW5pbmcgdGhlIGtleS5cbiAgICogQHBhcmFtIHtzdHJpbmd9IGtleSAtIFRoZSBrZXkgZm9yIHdoaWNoIHRoZSB0dGwgcmVtYWluaW5nIGlzIHJlcXVlc3RlZC5cbiAgICogQHBhcmFtIHtudW1iZXJ9IHR0bE1pbGxpc2Vjb25kcyAtIFRoZSB0dGwgaW4gbWlsbGlzZWNvbmRzIHRoYXQgc2hvdWxkIG92ZXJ3cml0ZSB0aGUgY3VycmVudCB0dGwuXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPENhY2hlVXBkYXRlVHRsLlJlc3BvbnNlPn1cbiAgICoge0BsaW5rIENhY2hlVXBkYXRlVHRsLlNldH0gd2hlbiB0aGUgdHRsIHdhcyBzdWNjZXNzZnVsbHkgb3ZlcndyaXR0ZW4uXG4gICAqIHtAbGluayBDYWNoZVVwZGF0ZVR0bC5NaXNzfSB3aGVuIHRoZSBrZXkgZG9lcyBub3QgZXhpc3QuXG4gICAqIHtAbGluayBDYWNoZVVwZGF0ZVR0bC5FcnJvcn0gb24gZmFpbHVyZS5cbiAgICovXG4gIHB1YmxpYyBhc3luYyB1cGRhdGVUdGwoXG4gICAgY2FjaGVOYW1lOiBzdHJpbmcsXG4gICAga2V5OiBzdHJpbmcgfCBVaW50OEFycmF5LFxuICAgIHR0bE1pbGxpc2Vjb25kczogbnVtYmVyXG4gICk6IFByb21pc2U8Q2FjaGVVcGRhdGVUdGwuUmVzcG9uc2U+IHtcbiAgICBjb25zdCBjbGllbnQgPSB0aGlzLmdldE5leHREYXRhQ2xpZW50KCk7XG4gICAgcmV0dXJuIGF3YWl0IGNsaWVudC51cGRhdGVUdGwoY2FjaGVOYW1lLCBrZXksIHR0bE1pbGxpc2Vjb25kcyk7XG4gIH1cblxuICAvKipcbiAgICogSW5jcmVhc2UgdGhlIHR0bCBvZiB0aGUga2V5IGluIHRoZSBjYWNoZSBpbiBtaWxsaXNlY29uZHMuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBjYWNoZU5hbWUgLSBUaGUgY2FjaGUgY29udGFpbmluZyB0aGUga2V5LlxuICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IC0gVGhlIGtleSBmb3Igd2hpY2ggdGhlIHR0bCByZW1haW5pbmcgaXMgcmVxdWVzdGVkLlxuICAgKiBAcGFyYW0ge251bWJlcn0gdHRsTWlsbGlzZWNvbmRzIC0gVGhlIHR0bCBpbiBtaWxsaXNlY29uZHMgdGhhdCBzaG91bGRcbiAgICogb3ZlcndyaXRlIHRoZSBjdXJyZW50IHR0bC4gU2hvdWxkIGJlIGdyZWF0ZXIgdGhhbiB0aGUgY3VycmVudCB0dGwuXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPENhY2hlSW5jcmVhc2VUdGwuUmVzcG9uc2U+fVxuICAgKiB7QGxpbmsgQ2FjaGVJbmNyZWFzZVR0bC5TZXR9IHdoZW4gdGhlIHR0bCB3YXMgc3VjY2Vzc2Z1bGx5IGluY3JlYXNlZC5cbiAgICoge0BsaW5rIENhY2hlSW5jcmVhc2VUdGwuTWlzc30gd2hlbiB0aGUga2V5IGRvZXMgbm90IGV4aXN0LlxuICAgKiB7QGxpbmsgQ2FjaGVJbmNyZWFzZVR0bC5FcnJvcn0gb24gZmFpbHVyZS5cbiAgICovXG4gIHB1YmxpYyBhc3luYyBpbmNyZWFzZVR0bChcbiAgICBjYWNoZU5hbWU6IHN0cmluZyxcbiAgICBrZXk6IHN0cmluZyB8IFVpbnQ4QXJyYXksXG4gICAgdHRsTWlsbGlzZWNvbmRzOiBudW1iZXJcbiAgKTogUHJvbWlzZTxDYWNoZUluY3JlYXNlVHRsLlJlc3BvbnNlPiB7XG4gICAgY29uc3QgY2xpZW50ID0gdGhpcy5nZXROZXh0RGF0YUNsaWVudCgpO1xuICAgIHJldHVybiBhd2FpdCBjbGllbnQuaW5jcmVhc2VUdGwoY2FjaGVOYW1lLCBrZXksIHR0bE1pbGxpc2Vjb25kcyk7XG4gIH1cblxuICAvKipcbiAgICogRGVjcmVhc2UgdGhlIHR0bCBvZiB0aGUga2V5IGluIHRoZSBjYWNoZSBpbiBtaWxsaXNlY29uZHMuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBjYWNoZU5hbWUgLSBUaGUgY2FjaGUgY29udGFpbmluZyB0aGUga2V5LlxuICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IC0gVGhlIGtleSBmb3Igd2hpY2ggdGhlIHR0bCByZW1haW5pbmcgaXMgcmVxdWVzdGVkLlxuICAgKiBAcGFyYW0ge251bWJlcn0gdHRsTWlsbGlzZWNvbmRzIC0gVGhlIHR0bCBpbiBtaWxsaXNlY29uZHMgdGhhdCBzaG91bGRcbiAgICogb3ZlcndyaXRlIHRoZSBjdXJyZW50IHR0bC4gU2hvdWxkIGJlIGxlc3MgdGhhbiB0aGUgY3VycmVudCB0dGwuXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPENhY2hlRGVjcmVhc2VUdGwuUmVzcG9uc2U+fVxuICAgKiB7QGxpbmsgQ2FjaGVEZWNyZWFzZVR0bC5TZXR9IHdoZW4gdGhlIHR0bCB3YXMgc3VjY2Vzc2Z1bGx5IGRlY3JlYXNlZC5cbiAgICoge0BsaW5rIENhY2hlRGVjcmVhc2VUdGwuTWlzc30gd2hlbiB0aGUga2V5IGRvZXMgbm90IGV4aXN0LlxuICAgKiB7QGxpbmsgQ2FjaGVEZWNyZWFzZVR0bC5FcnJvcn0gb24gZmFpbHVyZS5cbiAgICovXG4gIHB1YmxpYyBhc3luYyBkZWNyZWFzZVR0bChcbiAgICBjYWNoZU5hbWU6IHN0cmluZyxcbiAgICBrZXk6IHN0cmluZyB8IFVpbnQ4QXJyYXksXG4gICAgdHRsTWlsbGlzZWNvbmRzOiBudW1iZXJcbiAgKTogUHJvbWlzZTxDYWNoZURlY3JlYXNlVHRsLlJlc3BvbnNlPiB7XG4gICAgY29uc3QgY2xpZW50ID0gdGhpcy5nZXROZXh0RGF0YUNsaWVudCgpO1xuICAgIHJldHVybiBhd2FpdCBjbGllbnQuZGVjcmVhc2VUdGwoY2FjaGVOYW1lLCBrZXksIHR0bE1pbGxpc2Vjb25kcyk7XG4gIH1cblxuICBwcm90ZWN0ZWQgZ2V0TmV4dERhdGFDbGllbnQoKTogSURhdGFDbGllbnQge1xuICAgIGNvbnN0IGNsaWVudCA9IHRoaXMuZGF0YUNsaWVudHNbdGhpcy5uZXh0RGF0YUNsaWVudEluZGV4XTtcbiAgICB0aGlzLm5leHREYXRhQ2xpZW50SW5kZXggPVxuICAgICAgKHRoaXMubmV4dERhdGFDbGllbnRJbmRleCArIDEpICUgdGhpcy5kYXRhQ2xpZW50cy5sZW5ndGg7XG4gICAgcmV0dXJuIGNsaWVudDtcbiAgfVxufVxuIl19