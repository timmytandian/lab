"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.InternalSuperUserPermissions = exports.decodeAuthToken = exports.populateAllEndpointsFromBaseEndpoint = void 0;
const errors_1 = require("../../errors");
const jwt_decode_1 = require("jwt-decode");
const validators_1 = require("./validators");
const string_1 = require("./string");
const permission_scope_1 = require("../../auth/tokens/permission-scope");
function decodeAuthTokenClaims(authToken) {
    return (0, jwt_decode_1.default)(authToken);
}
function populateAllEndpointsFromBaseEndpoint(baseEndpoint) {
    return {
        controlEndpoint: `control.${baseEndpoint}`,
        cacheEndpoint: `cache.${baseEndpoint}`,
        tokenEndpoint: `token.${baseEndpoint}`,
        vectorEndpoint: `vector.${baseEndpoint}`,
    };
}
exports.populateAllEndpointsFromBaseEndpoint = populateAllEndpointsFromBaseEndpoint;
/**
 * @param {string} token
 * @returns TokenAndEndpoints
 */
const decodeAuthToken = (token) => {
    if (!token) {
        throw new errors_1.InvalidArgumentError('malformed auth token');
    }
    try {
        // v1 api tokens don't have an endpoint as part of their claims. Instead, when the SDK returns tokens, we
        // give it to them as a base64 encoded string of '{ "api_key": "<the key>", "endpoint": "prod.momentohq.com" }'.
        // Since in the near future, most customers are going to be using these newer tokens, we are first checking to see if
        // they are base64 encoded, which will tell us that they are our v1 api tokens. If its not, we will fall back to decoding
        // it as one of our legacy jwts.
        if ((0, validators_1.isBase64)(token)) {
            const base64DecodedToken = JSON.parse((0, string_1.decodeFromBase64)(token));
            if (!base64DecodedToken.endpoint || !base64DecodedToken.api_key) {
                throw new errors_1.InvalidArgumentError('failed to parse token');
            }
            return {
                ...populateAllEndpointsFromBaseEndpoint(base64DecodedToken.endpoint),
                authToken: base64DecodedToken.api_key,
            };
        }
        else {
            // This decode function uses generics to advertise that we will usually expect to find the LegacyClaims.  However,
            // if the token is a valid JWT but not actually one of our legacy tokens, the endpoint claims will be undefined,
            // which is why the return type for this function specifies that the controlEndpoint/cacheEndpoint may be undefined.
            const decodedLegacyToken = decodeAuthTokenClaims(token);
            return {
                controlEndpoint: decodedLegacyToken.cp,
                cacheEndpoint: decodedLegacyToken.c,
                tokenEndpoint: decodedLegacyToken.c,
                vectorEndpoint: decodedLegacyToken.c,
                authToken: token,
            };
        }
    }
    catch (e) {
        // eslint-disable-next-line @typescript-eslint/restrict-template-expressions
        throw new errors_1.InvalidArgumentError(`failed to parse token: ${e}`);
    }
};
exports.decodeAuthToken = decodeAuthToken;
class InternalSuperUserPermissions extends permission_scope_1.PredefinedScope {
}
exports.InternalSuperUserPermissions = InternalSuperUserPermissions;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYXV0aC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uL3NyYy9pbnRlcm5hbC91dGlscy9hdXRoLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7OztBQUFBLHlDQUFrRDtBQUNsRCwyQ0FBbUM7QUFDbkMsNkNBQXNDO0FBQ3RDLHFDQUEwQztBQUMxQyx5RUFBbUU7QUFrQm5FLFNBQVMscUJBQXFCLENBQUksU0FBaUI7SUFDakQsT0FBTyxJQUFBLG9CQUFTLEVBQUksU0FBUyxDQUFDLENBQUM7QUFDakMsQ0FBQztBQW1CRCxTQUFnQixvQ0FBb0MsQ0FDbEQsWUFBb0I7SUFFcEIsT0FBTztRQUNMLGVBQWUsRUFBRSxXQUFXLFlBQVksRUFBRTtRQUMxQyxhQUFhLEVBQUUsU0FBUyxZQUFZLEVBQUU7UUFDdEMsYUFBYSxFQUFFLFNBQVMsWUFBWSxFQUFFO1FBQ3RDLGNBQWMsRUFBRSxVQUFVLFlBQVksRUFBRTtLQUN6QyxDQUFDO0FBQ0osQ0FBQztBQVRELG9GQVNDO0FBRUQ7OztHQUdHO0FBQ0ksTUFBTSxlQUFlLEdBQUcsQ0FBQyxLQUFjLEVBQXFCLEVBQUU7SUFDbkUsSUFBSSxDQUFDLEtBQUssRUFBRTtRQUNWLE1BQU0sSUFBSSw2QkFBb0IsQ0FBQyxzQkFBc0IsQ0FBQyxDQUFDO0tBQ3hEO0lBRUQsSUFBSTtRQUNGLHlHQUF5RztRQUN6RyxnSEFBZ0g7UUFDaEgscUhBQXFIO1FBQ3JILHlIQUF5SDtRQUN6SCxnQ0FBZ0M7UUFDaEMsSUFBSSxJQUFBLHFCQUFRLEVBQUMsS0FBSyxDQUFDLEVBQUU7WUFDbkIsTUFBTSxrQkFBa0IsR0FBRyxJQUFJLENBQUMsS0FBSyxDQUNuQyxJQUFBLHlCQUFnQixFQUFDLEtBQUssQ0FBQyxDQUNBLENBQUM7WUFDMUIsSUFBSSxDQUFDLGtCQUFrQixDQUFDLFFBQVEsSUFBSSxDQUFDLGtCQUFrQixDQUFDLE9BQU8sRUFBRTtnQkFDL0QsTUFBTSxJQUFJLDZCQUFvQixDQUFDLHVCQUF1QixDQUFDLENBQUM7YUFDekQ7WUFDRCxPQUFPO2dCQUNMLEdBQUcsb0NBQW9DLENBQUMsa0JBQWtCLENBQUMsUUFBUSxDQUFDO2dCQUNwRSxTQUFTLEVBQUUsa0JBQWtCLENBQUMsT0FBTzthQUN0QyxDQUFDO1NBQ0g7YUFBTTtZQUNMLGtIQUFrSDtZQUNsSCxnSEFBZ0g7WUFDaEgsb0hBQW9IO1lBQ3BILE1BQU0sa0JBQWtCLEdBQUcscUJBQXFCLENBQWUsS0FBSyxDQUFDLENBQUM7WUFDdEUsT0FBTztnQkFDTCxlQUFlLEVBQUUsa0JBQWtCLENBQUMsRUFBRTtnQkFDdEMsYUFBYSxFQUFFLGtCQUFrQixDQUFDLENBQUM7Z0JBQ25DLGFBQWEsRUFBRSxrQkFBa0IsQ0FBQyxDQUFDO2dCQUNuQyxjQUFjLEVBQUUsa0JBQWtCLENBQUMsQ0FBQztnQkFDcEMsU0FBUyxFQUFFLEtBQUs7YUFDakIsQ0FBQztTQUNIO0tBQ0Y7SUFBQyxPQUFPLENBQUMsRUFBRTtRQUNWLDRFQUE0RTtRQUM1RSxNQUFNLElBQUksNkJBQW9CLENBQUMsMEJBQTBCLENBQUMsRUFBRSxDQUFDLENBQUM7S0FDL0Q7QUFDSCxDQUFDLENBQUM7QUF2Q1csUUFBQSxlQUFlLG1CQXVDMUI7QUFFRixNQUFhLDRCQUE2QixTQUFRLGtDQUFlO0NBQUc7QUFBcEUsb0VBQW9FIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHtJbnZhbGlkQXJndW1lbnRFcnJvcn0gZnJvbSAnLi4vLi4vZXJyb3JzJztcbmltcG9ydCBqd3REZWNvZGUgZnJvbSAnand0LWRlY29kZSc7XG5pbXBvcnQge2lzQmFzZTY0fSBmcm9tICcuL3ZhbGlkYXRvcnMnO1xuaW1wb3J0IHtkZWNvZGVGcm9tQmFzZTY0fSBmcm9tICcuL3N0cmluZyc7XG5pbXBvcnQge1ByZWRlZmluZWRTY29wZX0gZnJvbSAnLi4vLi4vYXV0aC90b2tlbnMvcGVybWlzc2lvbi1zY29wZSc7XG5cbmV4cG9ydCBpbnRlcmZhY2UgTGVnYWN5Q2xhaW1zIHtcbiAgLyoqXG4gICAqIGNvbnRyb2wgcGxhbmUgZW5kcG9pbnRcbiAgICovXG4gIGNwOiBzdHJpbmc7XG4gIC8qKlxuICAgKiBjYWNoZSBlbmRwb2ludFxuICAgKi9cbiAgYzogc3RyaW5nO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIEJhc2U2NERlY29kZWRWMVRva2VuIHtcbiAgYXBpX2tleTogc3RyaW5nO1xuICBlbmRwb2ludDogc3RyaW5nO1xufVxuXG5mdW5jdGlvbiBkZWNvZGVBdXRoVG9rZW5DbGFpbXM8VD4oYXV0aFRva2VuOiBzdHJpbmcpOiBUIHtcbiAgcmV0dXJuIGp3dERlY29kZTxUPihhdXRoVG9rZW4pO1xufVxuXG5pbnRlcmZhY2UgVG9rZW5BbmRFbmRwb2ludHMge1xuICAvLyBJZiB3ZSBkZWNvZGUgYSBKV1QgdGhhdCBkb2Vzbid0IGFjdHVhbGx5IGhhdmUgdGhlIGNvbnRyb2xFbmRwb2ludC9jYWNoZUVuZHBvaW50IGNsYWltcywgdGhlbiB0aGV5IHdpbGwgY29tZSBiYWNrXG4gIC8vIGFzIHVuZGVmaW5lZDsgdGh1cyB3ZSBuZWVkIHRoZSB0eXBlcyBoZXJlIHRvIGJlIGBzdHJpbmcgfCB1bmRlZmluZWRgLlxuICBjb250cm9sRW5kcG9pbnQ6IHN0cmluZyB8IHVuZGVmaW5lZDtcbiAgY2FjaGVFbmRwb2ludDogc3RyaW5nIHwgdW5kZWZpbmVkO1xuICB0b2tlbkVuZHBvaW50OiBzdHJpbmcgfCB1bmRlZmluZWQ7XG4gIHZlY3RvckVuZHBvaW50OiBzdHJpbmcgfCB1bmRlZmluZWQ7XG4gIGF1dGhUb2tlbjogc3RyaW5nO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIEFsbEVuZHBvaW50cyB7XG4gIGNvbnRyb2xFbmRwb2ludDogc3RyaW5nO1xuICBjYWNoZUVuZHBvaW50OiBzdHJpbmc7XG4gIHRva2VuRW5kcG9pbnQ6IHN0cmluZztcbiAgdmVjdG9yRW5kcG9pbnQ6IHN0cmluZztcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHBvcHVsYXRlQWxsRW5kcG9pbnRzRnJvbUJhc2VFbmRwb2ludChcbiAgYmFzZUVuZHBvaW50OiBzdHJpbmdcbik6IEFsbEVuZHBvaW50cyB7XG4gIHJldHVybiB7XG4gICAgY29udHJvbEVuZHBvaW50OiBgY29udHJvbC4ke2Jhc2VFbmRwb2ludH1gLFxuICAgIGNhY2hlRW5kcG9pbnQ6IGBjYWNoZS4ke2Jhc2VFbmRwb2ludH1gLFxuICAgIHRva2VuRW5kcG9pbnQ6IGB0b2tlbi4ke2Jhc2VFbmRwb2ludH1gLFxuICAgIHZlY3RvckVuZHBvaW50OiBgdmVjdG9yLiR7YmFzZUVuZHBvaW50fWAsXG4gIH07XG59XG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IHRva2VuXG4gKiBAcmV0dXJucyBUb2tlbkFuZEVuZHBvaW50c1xuICovXG5leHBvcnQgY29uc3QgZGVjb2RlQXV0aFRva2VuID0gKHRva2VuPzogc3RyaW5nKTogVG9rZW5BbmRFbmRwb2ludHMgPT4ge1xuICBpZiAoIXRva2VuKSB7XG4gICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKCdtYWxmb3JtZWQgYXV0aCB0b2tlbicpO1xuICB9XG5cbiAgdHJ5IHtcbiAgICAvLyB2MSBhcGkgdG9rZW5zIGRvbid0IGhhdmUgYW4gZW5kcG9pbnQgYXMgcGFydCBvZiB0aGVpciBjbGFpbXMuIEluc3RlYWQsIHdoZW4gdGhlIFNESyByZXR1cm5zIHRva2Vucywgd2VcbiAgICAvLyBnaXZlIGl0IHRvIHRoZW0gYXMgYSBiYXNlNjQgZW5jb2RlZCBzdHJpbmcgb2YgJ3sgXCJhcGlfa2V5XCI6IFwiPHRoZSBrZXk+XCIsIFwiZW5kcG9pbnRcIjogXCJwcm9kLm1vbWVudG9ocS5jb21cIiB9Jy5cbiAgICAvLyBTaW5jZSBpbiB0aGUgbmVhciBmdXR1cmUsIG1vc3QgY3VzdG9tZXJzIGFyZSBnb2luZyB0byBiZSB1c2luZyB0aGVzZSBuZXdlciB0b2tlbnMsIHdlIGFyZSBmaXJzdCBjaGVja2luZyB0byBzZWUgaWZcbiAgICAvLyB0aGV5IGFyZSBiYXNlNjQgZW5jb2RlZCwgd2hpY2ggd2lsbCB0ZWxsIHVzIHRoYXQgdGhleSBhcmUgb3VyIHYxIGFwaSB0b2tlbnMuIElmIGl0cyBub3QsIHdlIHdpbGwgZmFsbCBiYWNrIHRvIGRlY29kaW5nXG4gICAgLy8gaXQgYXMgb25lIG9mIG91ciBsZWdhY3kgand0cy5cbiAgICBpZiAoaXNCYXNlNjQodG9rZW4pKSB7XG4gICAgICBjb25zdCBiYXNlNjREZWNvZGVkVG9rZW4gPSBKU09OLnBhcnNlKFxuICAgICAgICBkZWNvZGVGcm9tQmFzZTY0KHRva2VuKVxuICAgICAgKSBhcyBCYXNlNjREZWNvZGVkVjFUb2tlbjtcbiAgICAgIGlmICghYmFzZTY0RGVjb2RlZFRva2VuLmVuZHBvaW50IHx8ICFiYXNlNjREZWNvZGVkVG9rZW4uYXBpX2tleSkge1xuICAgICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoJ2ZhaWxlZCB0byBwYXJzZSB0b2tlbicpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgLi4ucG9wdWxhdGVBbGxFbmRwb2ludHNGcm9tQmFzZUVuZHBvaW50KGJhc2U2NERlY29kZWRUb2tlbi5lbmRwb2ludCksXG4gICAgICAgIGF1dGhUb2tlbjogYmFzZTY0RGVjb2RlZFRva2VuLmFwaV9rZXksXG4gICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBUaGlzIGRlY29kZSBmdW5jdGlvbiB1c2VzIGdlbmVyaWNzIHRvIGFkdmVydGlzZSB0aGF0IHdlIHdpbGwgdXN1YWxseSBleHBlY3QgdG8gZmluZCB0aGUgTGVnYWN5Q2xhaW1zLiAgSG93ZXZlcixcbiAgICAgIC8vIGlmIHRoZSB0b2tlbiBpcyBhIHZhbGlkIEpXVCBidXQgbm90IGFjdHVhbGx5IG9uZSBvZiBvdXIgbGVnYWN5IHRva2VucywgdGhlIGVuZHBvaW50IGNsYWltcyB3aWxsIGJlIHVuZGVmaW5lZCxcbiAgICAgIC8vIHdoaWNoIGlzIHdoeSB0aGUgcmV0dXJuIHR5cGUgZm9yIHRoaXMgZnVuY3Rpb24gc3BlY2lmaWVzIHRoYXQgdGhlIGNvbnRyb2xFbmRwb2ludC9jYWNoZUVuZHBvaW50IG1heSBiZSB1bmRlZmluZWQuXG4gICAgICBjb25zdCBkZWNvZGVkTGVnYWN5VG9rZW4gPSBkZWNvZGVBdXRoVG9rZW5DbGFpbXM8TGVnYWN5Q2xhaW1zPih0b2tlbik7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBjb250cm9sRW5kcG9pbnQ6IGRlY29kZWRMZWdhY3lUb2tlbi5jcCxcbiAgICAgICAgY2FjaGVFbmRwb2ludDogZGVjb2RlZExlZ2FjeVRva2VuLmMsXG4gICAgICAgIHRva2VuRW5kcG9pbnQ6IGRlY29kZWRMZWdhY3lUb2tlbi5jLFxuICAgICAgICB2ZWN0b3JFbmRwb2ludDogZGVjb2RlZExlZ2FjeVRva2VuLmMsXG4gICAgICAgIGF1dGhUb2tlbjogdG9rZW4sXG4gICAgICB9O1xuICAgIH1cbiAgfSBjYXRjaCAoZSkge1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvcmVzdHJpY3QtdGVtcGxhdGUtZXhwcmVzc2lvbnNcbiAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoYGZhaWxlZCB0byBwYXJzZSB0b2tlbjogJHtlfWApO1xuICB9XG59O1xuXG5leHBvcnQgY2xhc3MgSW50ZXJuYWxTdXBlclVzZXJQZXJtaXNzaW9ucyBleHRlbmRzIFByZWRlZmluZWRTY29wZSB7fVxuIl19